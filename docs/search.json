[
  {
    "objectID": "utility/process_fixed_width_data.html",
    "href": "utility/process_fixed_width_data.html",
    "title": "Computational Tools for Physics",
    "section": "",
    "text": "import polars as pl\n\n\ndef process(f, col_starts, col_names, drop_cols, skip=0):\n    '''\n    Process data from a text file with fixed width columns.\n    @param f: path to document which is processed\n    @param col_starts: list of start positions for columns\n    @param col_names: list of column names\n    @param drop_cols: list of column names that are dropped\n    @param skip: number of rows to skip\n    @return: returns a DataFrame containg the processed columns\n    '''\n    \n    raw = pl.read_csv(\n        f,\n        has_header = False,\n        skip_lines = skip,\n        new_columns = ['full_str']\n    )\n\n    max_len = (raw\n        .with_columns(pl.col('full_str').str.len_chars().alias('len'))\n        .select(pl.max('len'))\n        .item(0, 0)\n              )\n    \n    col_starts.append(max_len)\n\n    column_names = col_names\n\n    return raw.with_columns(\n        [\n            pl.col('full_str').str.slice(col_starts[i]-1, col_starts[i+1]-col_starts[i]).str.strip_chars().alias(col)\n            for i, col in enumerate(column_names)\n        ]\n    ).drop('full_str').drop(drop_cols)"
  },
  {
    "objectID": "sympy/equations.html",
    "href": "sympy/equations.html",
    "title": "Solving Equations with SymPy",
    "section": "",
    "text": "SymPy can be used to find formal solutions to a large number of equations or systems of equations.\n\nSolve() with expressions\nBy default, expressions are assumed to be equal to zero. An equation like \\(f(x) = g(x)\\) can be turned into an expression \\(f(x) - g(x)\\).\n\nimport sympy as sp\n\nx = sp.symbols('x')\n\n# solve the equation 2x = 3 for x\nexp1 = 2 * x - 3\nsol1 = sp.solve(exp1, x)\n# solve() returns a list of solutions, even if there is only one solution\ndisplay(sol1[0]) # display the first (in this case only) solution\n\n\\(\\displaystyle \\frac{3}{2}\\)\n\n\n\n# solve the quadratic equation ax^2 + bx + c = 0 for x\na, b, c = sp.symbols('a b c')\nexp2 = a * x**2 + b * x + c\nsol2 = sp.solve(exp2, x)\n# display all solutions\nfor sol in sol2:\n    display(sol)\n\n# apply general solution to specific values of a, b, c\nvals = {a: 1, b: -3, c: 2}\nsol2_vals = [sol.subs(vals) for sol in sol2]\n# display the specific solutions\nfor sol in sol2_vals:\n    display(sol)\n\n\\(\\displaystyle \\frac{- b - \\sqrt{- 4 a c + b^{2}}}{2 a}\\)\n\n\n\\(\\displaystyle \\frac{- b + \\sqrt{- 4 a c + b^{2}}}{2 a}\\)\n\n\n\\(\\displaystyle 1\\)\n\n\n\\(\\displaystyle 2\\)\n\n\n\n\n# solve the equation sin(x) = cos(2x) for x\nexp3 = sp.sin(x) - sp.cos(2*x)\n\n# solve() ignores the periodicity of trigonometric functions\n# and returns a list of solutions, even if there are infinitely many\n# solutions (e.g., for sin(x) = 0, the solutions are x = n*pi for n in Z)\nsol3a = sp.solve(exp3, x)\nfor sol in sol3a:\n    display(sol)\n\n# solveset() can be used to find all solutions in a given domain\nsol3b = sp.solveset(exp3, x) # solve the equation sin(x) = cos(x) for x using solveset\ndisplay(sol3b)\n\n\\(\\displaystyle - \\frac{\\pi}{2}\\)\n\n\n\\(\\displaystyle \\frac{\\pi}{6}\\)\n\n\n\\(\\displaystyle \\frac{5 \\pi}{6}\\)\n\n\n\\(\\displaystyle \\left\\{2 n \\pi + \\frac{3 \\pi}{2}\\; \\middle|\\; n \\in \\mathbb{Z}\\right\\} \\cup \\left\\{2 n \\pi + \\frac{5 \\pi}{6}\\; \\middle|\\; n \\in \\mathbb{Z}\\right\\} \\cup \\left\\{2 n \\pi + \\frac{\\pi}{6}\\; \\middle|\\; n \\in \\mathbb{Z}\\right\\}\\)\n\n\n\nz = sp.Symbol('z')\nx = sp.Symbol('x', real=True)\n\n# solve the equation z^3 + 1 = 0 for z, where z can be comples\nexp4a = z**3 + 1\nsol4a = sp.solve(exp4a, z)\nprint(\"Solutions for z^3 + 1 = 0:\")\nfor sol in sol4a:\n    display(sol)\n\n#solve the equation x^3 + 1 = 0 for x, where x is real\nexp4b = x**3 + 1\nsol4b = sp.solve(exp4b, x)\nprint(\"Solutions for x^3 + 1 = 0:\")\nfor sol in sol4b:\n    display(sol)\n\nSolutions for z^3 + 1 = 0:\n\n\n\\(\\displaystyle -1\\)\n\n\n\\(\\displaystyle \\frac{1}{2} - \\frac{\\sqrt{3} i}{2}\\)\n\n\n\\(\\displaystyle \\frac{1}{2} + \\frac{\\sqrt{3} i}{2}\\)\n\n\nSolutions for x^3 + 1 = 0:\n\n\n\\(\\displaystyle -1\\)\n\n\n\n\nEquations\nEquations can also be defined using the method Eq() with the left and right hand sides of the equation as arguments.\n\nx, a, b = sp.symbols('x a b')\n# define equation e^(2x) = 3x + 2\neq1 = sp.Eq(sp.exp(a*x), b)\ndisplay(sp.solve(eq1, x)[0])\n\n\\(\\displaystyle \\frac{\\log{\\left(b \\right)}}{a}\\)\n\n\n\n\nSystems of equations\nFor systems of equations, both the equations and the variables for which the system should be solved are passed to the solve() method as lists.\n\n# solve a system of two linear equations\nx, y = sp.symbols('x y')\n# define system of equations\neq1 = sp.Eq(x + 2*y, 2)\neq2 = sp.Eq(x - y, 4)\n# solve system of equations\nsol_sys = sp.solve([eq1, eq2], [x, y])\ndisplay(sol_sys)\n\n{x: 10/3, y: -2/3}\n\n\n\n# solve a system of two linear equations with parameters\nx, y, a, b = sp.symbols('x y a b')\n# define system of equations\neq1 = sp.Eq(x + 2*y, a)\neq2 = sp.Eq(2*x - y, b)\n# solve system of equations\nsol_sys2 = sp.solve([eq1, eq2], [x, y])\ndisplay(sol_sys2)\n\n{x: a/5 + 2*b/5, y: 2*a/5 - b/5}\n\n\n\n# solve a system of two nonlinear equations\nx, y = sp.symbols('x y')\n# define system of equations\neq1 = sp.Eq(x**2 + y**2, 13)\neq2 = sp.Eq(x**3 - y, 5)\n# solve system of equations\nsol_sys_nonlinear = sp.solve([eq1, eq2], [x, y], dict=True)\ndisplay(sol_sys_nonlinear)\n\n[{x: 2, y: 3}]\n\n\n\n# some systems cannot be solved symbolically, but only numerically\n\nx, y = sp.symbols('x y')\n# define system of equations\neq1 = sp.Eq(sp.sin(2*x), -y**2)\neq2 = sp.Eq(sp.cos(x**2), y)\n\n# try to solve the system symbolically\ntry:\n    sol_sys_nonlinear_symbolic = sp.solve([eq1, eq2], [x, y])\n    display(sol_sys_nonlinear_symbolic)\nexcept NotImplementedError as e:\n    print(\"Symbolic solution failed:\", e)\n\n# solve the system numerically with initial guesses for x and y\nsol_sys_nonlinear_numeric = sp.nsolve([eq1, eq2], [x, y], [-1, 1])\ndisplay(sol_sys_nonlinear_numeric)\n\nSymbolic solution failed: could not solve 2*sin(x)*cos(x) + cos(x**2)**2\n\n\n\\(\\displaystyle \\left[\\begin{matrix}-0.563099692731064\\\\0.950149510263295\\end{matrix}\\right]\\)",
    "crumbs": [
      "SymPy",
      "Solving Equations with SymPy"
    ]
  },
  {
    "objectID": "scipy/integration.html",
    "href": "scipy/integration.html",
    "title": "Numerical Integration",
    "section": "",
    "text": "Expressing the integral in terms of basic functions is not possible for arbitrary integrands. NumPy and SciPy provide fast and reliable methods to calculate definite integrals of arbitrary functions numerically.\n\nimport sympy as sp\n\nimport numpy as np\nfrom scipy.differentiate import derivative\nfrom scipy.integrate import quad\n\nThe quad function takes the function and the lower and upper boundary as parameters.\n\ndef f(x):\n    '''define function'''\n\n    return np.exp(-x**2)\n\n\nintegral, error = quad(f, -1, 1) # calculate the integral and its function\n\nprint(f'integral: {integral}')\n\nintegral: 1.493648265624854\n\n\n\nSymbolic vs numerical integration\nSymPy allows to find expressions for a large number of integrals, and it can also evaluate integrals numerically.\n\n\nx = sp.Symbol('x') # define x as a symbolic variable\nisp = sp.integrate(sp.exp(-x**2), (x, -1, 1)) # find the integral analytically\nispN = sp.N(isp, 20) # numerically evaluate the value (20 digits)\n\nprint(f'value found with SymPy: {ispN}')\nprint('This is the value of the following expression (erf is the error function):')\ndisplay(isp)\n\nvalue found with SymPy: 1.4936482656248540508\nThis is the value of the following expression (erf is the error function):\n\n\n\\(\\displaystyle \\sqrt{\\pi} \\operatorname{erf}{\\left(1 \\right)}\\)\n\n\nA speed comparison shows that SciPy is much more efficient when it comes to the numerical calculation.\n\n%%timeit\nquad(f, -1, 1) # time the numerical integration with SciPy\n\n11.8 μs ± 385 ns per loop (mean ± std. dev. of 7 runs, 100,000 loops each)\n\n\n\n%%timeit\nsp.integrate(sp.exp(-x**2), (x, -1, 1)) # time the symbolic integration with SymPy\n\n17 ms ± 424 μs per loop (mean ± std. dev. of 7 runs, 100 loops each)\n\n\nFor this example, SciPy is more than 1000 times faster than SymPy! On the other hand, since the integral can be expressed in terms of a known function, it is possible to just determine the (indefinite) integral once and then calculate the definite integral using this function.\n\n%%timeit\nsol = sp.integrate(sp.exp(-x**2), x) # indefinite integral\n\n11 ms ± 487 μs per loop (mean ± std. dev. of 7 runs, 100 loops each)\n\n\n\nsol = sp.integrate(sp.exp(-x**2), x) # indefinite integral\n\n\n%%timeit\nsp.N(sol.subs({x: 1}) - sol.subs({x: -1})) # definite integral using the indefinite integral\n\n98.6 μs ± 2.99 μs per loop (mean ± std. dev. of 7 runs, 10,000 loops each)",
    "crumbs": [
      "SciPy",
      "Numerical Integration"
    ]
  },
  {
    "objectID": "scipy/curvefit.html",
    "href": "scipy/curvefit.html",
    "title": "Curve Fit",
    "section": "",
    "text": "A common task in physics is to visualise measured data and to compare it to a theoretical prediction. If there is at least one free parameter (e.g. the acceleration of a moving object), we have to optimise the function to fit to the data as well as possible. This is referred to as a curve fit.",
    "crumbs": [
      "SciPy",
      "Curve Fit"
    ]
  },
  {
    "objectID": "scipy/curvefit.html#example-uniform-motion",
    "href": "scipy/curvefit.html#example-uniform-motion",
    "title": "Curve Fit",
    "section": "Example: Uniform motion",
    "text": "Example: Uniform motion\nA low-friction cart slides down a slightly inclined track. Its position is measured at regular time intervals. We assume errors of 0.05 s for the time and 0.1 cm for the position measurements.\n\nDefine arrays for measured data\n\nimport numpy as np\n\ntime = np.array([0.00, 0.50, 1.00, 1.50, 2.00, 2.50, 3.00, 3.50]) # time in s\npos = np.array([12.3, 15.2, 24.3, 39.4, 60.5, 87.1, 120.3, 159.2]) # position in cm\n\ndt = 0.05 # error for time in s\ndx = 0.2 # error for position in cm\n\n\n\nVisualise data with a scatter plot\n\nimport matplotlib.pyplot as plt\n\nplt.errorbar(time, pos, fmt='.', color='blue', xerr=dt, yerr=dx, capsize=2)\nplt.xlabel('time (s)')\nplt.ylabel('position (cm)')\nplt.show()\n\n\n\n\n\n\n\n\nThe error bars are so small that they can barely be seen. In order to visually confirm the quality of a fit function later on, we will have to find a solution to this problem.\n\n\nFit a model to the data\nFor a quantitative analysis we usually want to compare the measured data to a theoretical model. This can be done by fitting a function to the data. The fit parameters are related to physical parameters.\nWe expect the motion to have a constant acceleration, i.e. the position should be a quadratic function of time.\n\nfrom scipy.optimize import curve_fit\n\n\ndef f(t, a, v0, x0):\n    \"\"\"\n    Fit function for a motion with constant acceleration.\n\n    The parameters are:\n    t    time\n    a    acceleration\n    v0   initial velocity\n    x0   initial position\n    The function returns the position at time t.\n    \"\"\"\n    return a/2 * t**2 + v0 * t + x0\n\n# The method curve_fit returns two lists:\n# coeff contains the fit parameters\n# pcov contains the covariance matrix, whose diagonal elements are a measure\n# of how accurately the fit parameters match the data (see below)\ncoeff, pcov = curve_fit(f, time, pos)\na, v0, x0 = coeff # fit parameters are in the order of the function definition\n\n\n\nVisualise data and model\n\nt = np.linspace(0, max(time), 100) # array with evenly spaced t values\nx = f(t, a, v0, x0) # array with positions predicted by fit function\n\nplt.plot(t, x, color='red', label='square fit')\nplt.errorbar(time, pos, fmt='.', color='blue', xerr=dt, yerr=dx, label='data')\nplt.xlabel('time (s)')\nplt.ylabel('position (cm)')\nplt.legend()\nplt.show()\n\n\n\n\n\n\n\n\n\n\nResidual plot\nThe model seems to describe the measured data quite accurately. To see even better if the fit function passes through the error ranges of the data points, we can create a residual plot, i.e. a plot of the deviation between the data points and the fit function.\n\nres = pos - f(time, a, v0, x0) # calculate residuals (measured - predicted)\n\nplt.errorbar(range(1, len(time)+1), res, fmt='.', color='blue', xerr=dt, yerr=dx, capsize=2)\nplt.xlabel('data point')\nplt.ylabel('residuals (cm)')\nplt.grid()\nplt.show()\n\n\n\n\n\n\n\n\nThe horizontal axis is within the error ranges for all but one data point (no. 6). This is quite convincing evidence that the theoretical model is a good description for the measured data.\n\n\nErrors of fit parameters\nThe curve_fit method returns the covariance matrix as a second return value. The diagonal elements are the squared errors for the fit parameters.\n\nsq_errors = np.diag(pcov) # assign diagonal elements of covariance matrix\nda, dv0, dx0 = np.sqrt(sq_errors) # square root corresponds to errors of fit parameters\n\nprint(f'acceleration:      a = ({a:.2f} ± {da:.2f}) cm/s^2')\nprint(f'initial velocity:  v_0 = ({v0:.2f} ± {dv0:.2f}) cm/s')\nprint(f'initial position:  x_0 = ({x0:.2f} ± {dx0:.2f}) cm')\n\nacceleration:      a = (23.92 ± 0.08) cm/s^2\ninitial velocity:  v_0 = (0.12 ± 0.15) cm/s\ninitial position:  x_0 = (12.25 ± 0.11) cm",
    "crumbs": [
      "SciPy",
      "Curve Fit"
    ]
  },
  {
    "objectID": "polars/intro_polars.html",
    "href": "polars/intro_polars.html",
    "title": "Polars",
    "section": "",
    "text": "There are several Python libraries that can be used to analyse large datasets. The most popular one is Pandas (https://pandas.pydata.org/), which is used for numerous projects in data science.\nA modern alternative to Pandas is Polars (https://pola.rs/), which is considered to be more efficient and faster than Pandas. If you are not invested in Pandas, there is no reason why you should not start with Polars as the data manipulation tool of your choice.\n\nImport Polars\n\nimport polars as pl\n\n\n\nDataFrames\nPolars works with DataFrames. A DataFrame can be compared to a spreadsheet with a number of columns each containing the same number of rows. Each column contains data of a given datatype (e.g. string, date, float).\n\nCreate a dataframe\nA dataframe can be created in different way, e.g. from a Python dictionary, from a file or a url, etc.\n\n# create dataframe from dictionary\ngrades = pl.DataFrame(\n    {\n        'subject': ['maths', 'physics', 'biology', 'chemistry'],\n        'grade': [4.5, 5.5, 5.5, 5],\n        'teacher': ['Bernoulli', 'Einstein', 'Darwin', 'Laue']\n    }\n)\n\ngrades\n\n\nshape: (4, 3)\n\n\n\nsubject\ngrade\nteacher\n\n\nstr\nf64\nstr\n\n\n\n\n\"maths\"\n4.5\n\"Bernoulli\"\n\n\n\"physics\"\n5.5\n\"Einstein\"\n\n\n\"biology\"\n5.5\n\"Darwin\"\n\n\n\"chemistry\"\n5.0\n\"Laue\"\n\n\n\n\n\n\n\n# create dataframe from csv file\npath = 'data/pokemon.csv'\npokemons = pl.read_csv(path, infer_schema_length=None)\n\npokemons # displays first 5 and last 5 rows; shape provides information about the number of rows and columns\n\n\nshape: (801, 41)\n\n\n\nabilities\nagainst_bug\nagainst_dark\nagainst_dragon\nagainst_electric\nagainst_fairy\nagainst_fight\nagainst_fire\nagainst_flying\nagainst_ghost\nagainst_grass\nagainst_ground\nagainst_ice\nagainst_normal\nagainst_poison\nagainst_psychic\nagainst_rock\nagainst_steel\nagainst_water\nattack\nbase_egg_steps\nbase_happiness\nbase_total\ncapture_rate\nclassfication\ndefense\nexperience_growth\nheight_m\nhp\njapanese_name\nname\npercentage_male\npokedex_number\nsp_attack\nsp_defense\nspeed\ntype1\ntype2\nweight_kg\ngeneration\nis_legendary\n\n\nstr\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\ni64\ni64\ni64\ni64\nstr\nstr\ni64\ni64\nf64\ni64\nstr\nstr\nf64\ni64\ni64\ni64\ni64\nstr\nstr\nf64\ni64\ni64\n\n\n\n\n\"['Overgrow', 'Chlorophyll']\"\n1.0\n1.0\n1.0\n0.5\n0.5\n0.5\n2.0\n2.0\n1.0\n0.25\n1.0\n2.0\n1.0\n1.0\n2.0\n1.0\n1.0\n0.5\n49\n5120\n70\n318\n\"45\"\n\"Seed Pokémon\"\n49\n1059860\n0.7\n45\n\"Fushigidaneフシギダネ\"\n\"Bulbasaur\"\n88.1\n1\n65\n65\n45\n\"grass\"\n\"poison\"\n6.9\n1\n0\n\n\n\"['Overgrow', 'Chlorophyll']\"\n1.0\n1.0\n1.0\n0.5\n0.5\n0.5\n2.0\n2.0\n1.0\n0.25\n1.0\n2.0\n1.0\n1.0\n2.0\n1.0\n1.0\n0.5\n62\n5120\n70\n405\n\"45\"\n\"Seed Pokémon\"\n63\n1059860\n1.0\n60\n\"Fushigisouフシギソウ\"\n\"Ivysaur\"\n88.1\n2\n80\n80\n60\n\"grass\"\n\"poison\"\n13.0\n1\n0\n\n\n\"['Overgrow', 'Chlorophyll']\"\n1.0\n1.0\n1.0\n0.5\n0.5\n0.5\n2.0\n2.0\n1.0\n0.25\n1.0\n2.0\n1.0\n1.0\n2.0\n1.0\n1.0\n0.5\n100\n5120\n70\n625\n\"45\"\n\"Seed Pokémon\"\n123\n1059860\n2.0\n80\n\"Fushigibanaフシギバナ\"\n\"Venusaur\"\n88.1\n3\n122\n120\n80\n\"grass\"\n\"poison\"\n100.0\n1\n0\n\n\n\"['Blaze', 'Solar Power']\"\n0.5\n1.0\n1.0\n1.0\n0.5\n1.0\n0.5\n1.0\n1.0\n0.5\n2.0\n0.5\n1.0\n1.0\n1.0\n2.0\n0.5\n2.0\n52\n5120\n70\n309\n\"45\"\n\"Lizard Pokémon\"\n43\n1059860\n0.6\n39\n\"Hitokageヒトカゲ\"\n\"Charmander\"\n88.1\n4\n60\n50\n65\n\"fire\"\nnull\n8.5\n1\n0\n\n\n\"['Blaze', 'Solar Power']\"\n0.5\n1.0\n1.0\n1.0\n0.5\n1.0\n0.5\n1.0\n1.0\n0.5\n2.0\n0.5\n1.0\n1.0\n1.0\n2.0\n0.5\n2.0\n64\n5120\n70\n405\n\"45\"\n\"Flame Pokémon\"\n58\n1059860\n1.1\n58\n\"Lizardoリザード\"\n\"Charmeleon\"\n88.1\n5\n80\n65\n80\n\"fire\"\nnull\n19.0\n1\n0\n\n\n…\n…\n…\n…\n…\n…\n…\n…\n…\n…\n…\n…\n…\n…\n…\n…\n…\n…\n…\n…\n…\n…\n…\n…\n…\n…\n…\n…\n…\n…\n…\n…\n…\n…\n…\n…\n…\n…\n…\n…\n…\n\n\n\"['Beast Boost']\"\n0.25\n1.0\n0.5\n2.0\n0.5\n1.0\n2.0\n0.5\n1.0\n0.25\n0.0\n1.0\n0.5\n0.0\n0.5\n1.0\n0.5\n1.0\n101\n30720\n0\n570\n\"25\"\n\"Launch Pokémon\"\n103\n1250000\n9.2\n97\n\"Tekkaguyaテッカグヤ\"\n\"Celesteela\"\nnull\n797\n107\n101\n61\n\"steel\"\n\"flying\"\n999.9\n7\n1\n\n\n\"['Beast Boost']\"\n1.0\n1.0\n0.5\n0.5\n0.5\n2.0\n4.0\n1.0\n1.0\n0.25\n1.0\n1.0\n0.5\n0.0\n0.5\n0.5\n0.5\n0.5\n181\n30720\n0\n570\n\"255\"\n\"Drawn Sword Pokémon\"\n131\n1250000\n0.3\n59\n\"Kamiturugiカミツルギ\"\n\"Kartana\"\nnull\n798\n59\n31\n109\n\"grass\"\n\"steel\"\n0.1\n7\n1\n\n\n\"['Beast Boost']\"\n2.0\n0.5\n2.0\n0.5\n4.0\n2.0\n0.5\n1.0\n0.5\n0.5\n1.0\n2.0\n1.0\n1.0\n0.0\n1.0\n1.0\n0.5\n101\n30720\n0\n570\n\"15\"\n\"Junkivore Pokémon\"\n53\n1250000\n5.5\n223\n\"Akuzikingアクジキング\"\n\"Guzzlord\"\nnull\n799\n97\n53\n43\n\"dark\"\n\"dragon\"\n888.0\n7\n1\n\n\n\"['Prism Armor']\"\n2.0\n2.0\n1.0\n1.0\n1.0\n0.5\n1.0\n1.0\n2.0\n1.0\n1.0\n1.0\n1.0\n1.0\n0.5\n1.0\n1.0\n1.0\n107\n30720\n0\n600\n\"3\"\n\"Prism Pokémon\"\n101\n1250000\n2.4\n97\n\"Necrozmaネクロズマ\"\n\"Necrozma\"\nnull\n800\n127\n89\n79\n\"psychic\"\nnull\n230.0\n7\n1\n\n\n\"['Soul-Heart']\"\n0.25\n0.5\n0.0\n1.0\n0.5\n1.0\n2.0\n0.5\n1.0\n0.5\n2.0\n0.5\n0.5\n0.0\n0.5\n0.5\n1.0\n1.0\n95\n30720\n0\n600\n\"3\"\n\"Artificial Pokémon\"\n115\n1250000\n1.0\n80\n\"Magearnaマギアナ\"\n\"Magearna\"\nnull\n801\n130\n115\n65\n\"steel\"\n\"fairy\"\n80.5\n7\n1\n\n\n\n\n\n\n\n\nFirst look at dataframe\n\nprint(f'shape: {pokemons.shape}') # show number of rows and number of columns\n\nshape: (801, 41)\n\n\n\ncols = pokemons.columns # list of column names\ndt = pokemons.dtypes # list of datatypes\n\nfor c, d in zip(cols, dt):\n    print(f'{c}: {d}')\n\nabilities: String\nagainst_bug: Float64\nagainst_dark: Float64\nagainst_dragon: Float64\nagainst_electric: Float64\nagainst_fairy: Float64\nagainst_fight: Float64\nagainst_fire: Float64\nagainst_flying: Float64\nagainst_ghost: Float64\nagainst_grass: Float64\nagainst_ground: Float64\nagainst_ice: Float64\nagainst_normal: Float64\nagainst_poison: Float64\nagainst_psychic: Float64\nagainst_rock: Float64\nagainst_steel: Float64\nagainst_water: Float64\nattack: Int64\nbase_egg_steps: Int64\nbase_happiness: Int64\nbase_total: Int64\ncapture_rate: String\nclassfication: String\ndefense: Int64\nexperience_growth: Int64\nheight_m: Float64\nhp: Int64\njapanese_name: String\nname: String\npercentage_male: Float64\npokedex_number: Int64\nsp_attack: Int64\nsp_defense: Int64\nspeed: Int64\ntype1: String\ntype2: String\nweight_kg: Float64\ngeneration: Int64\nis_legendary: Int64\n\n\n\npokemons.head(5) # display first n rows\n\n\nshape: (5, 41)\n\n\n\nabilities\nagainst_bug\nagainst_dark\nagainst_dragon\nagainst_electric\nagainst_fairy\nagainst_fight\nagainst_fire\nagainst_flying\nagainst_ghost\nagainst_grass\nagainst_ground\nagainst_ice\nagainst_normal\nagainst_poison\nagainst_psychic\nagainst_rock\nagainst_steel\nagainst_water\nattack\nbase_egg_steps\nbase_happiness\nbase_total\ncapture_rate\nclassfication\ndefense\nexperience_growth\nheight_m\nhp\njapanese_name\nname\npercentage_male\npokedex_number\nsp_attack\nsp_defense\nspeed\ntype1\ntype2\nweight_kg\ngeneration\nis_legendary\n\n\nstr\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\ni64\ni64\ni64\ni64\nstr\nstr\ni64\ni64\nf64\ni64\nstr\nstr\nf64\ni64\ni64\ni64\ni64\nstr\nstr\nf64\ni64\ni64\n\n\n\n\n\"['Overgrow', 'Chlorophyll']\"\n1.0\n1.0\n1.0\n0.5\n0.5\n0.5\n2.0\n2.0\n1.0\n0.25\n1.0\n2.0\n1.0\n1.0\n2.0\n1.0\n1.0\n0.5\n49\n5120\n70\n318\n\"45\"\n\"Seed Pokémon\"\n49\n1059860\n0.7\n45\n\"Fushigidaneフシギダネ\"\n\"Bulbasaur\"\n88.1\n1\n65\n65\n45\n\"grass\"\n\"poison\"\n6.9\n1\n0\n\n\n\"['Overgrow', 'Chlorophyll']\"\n1.0\n1.0\n1.0\n0.5\n0.5\n0.5\n2.0\n2.0\n1.0\n0.25\n1.0\n2.0\n1.0\n1.0\n2.0\n1.0\n1.0\n0.5\n62\n5120\n70\n405\n\"45\"\n\"Seed Pokémon\"\n63\n1059860\n1.0\n60\n\"Fushigisouフシギソウ\"\n\"Ivysaur\"\n88.1\n2\n80\n80\n60\n\"grass\"\n\"poison\"\n13.0\n1\n0\n\n\n\"['Overgrow', 'Chlorophyll']\"\n1.0\n1.0\n1.0\n0.5\n0.5\n0.5\n2.0\n2.0\n1.0\n0.25\n1.0\n2.0\n1.0\n1.0\n2.0\n1.0\n1.0\n0.5\n100\n5120\n70\n625\n\"45\"\n\"Seed Pokémon\"\n123\n1059860\n2.0\n80\n\"Fushigibanaフシギバナ\"\n\"Venusaur\"\n88.1\n3\n122\n120\n80\n\"grass\"\n\"poison\"\n100.0\n1\n0\n\n\n\"['Blaze', 'Solar Power']\"\n0.5\n1.0\n1.0\n1.0\n0.5\n1.0\n0.5\n1.0\n1.0\n0.5\n2.0\n0.5\n1.0\n1.0\n1.0\n2.0\n0.5\n2.0\n52\n5120\n70\n309\n\"45\"\n\"Lizard Pokémon\"\n43\n1059860\n0.6\n39\n\"Hitokageヒトカゲ\"\n\"Charmander\"\n88.1\n4\n60\n50\n65\n\"fire\"\nnull\n8.5\n1\n0\n\n\n\"['Blaze', 'Solar Power']\"\n0.5\n1.0\n1.0\n1.0\n0.5\n1.0\n0.5\n1.0\n1.0\n0.5\n2.0\n0.5\n1.0\n1.0\n1.0\n2.0\n0.5\n2.0\n64\n5120\n70\n405\n\"45\"\n\"Flame Pokémon\"\n58\n1059860\n1.1\n58\n\"Lizardoリザード\"\n\"Charmeleon\"\n88.1\n5\n80\n65\n80\n\"fire\"\nnull\n19.0\n1\n0\n\n\n\n\n\n\n\npokemons.tail(5) # display last n rows\n\n\nshape: (5, 41)\n\n\n\nabilities\nagainst_bug\nagainst_dark\nagainst_dragon\nagainst_electric\nagainst_fairy\nagainst_fight\nagainst_fire\nagainst_flying\nagainst_ghost\nagainst_grass\nagainst_ground\nagainst_ice\nagainst_normal\nagainst_poison\nagainst_psychic\nagainst_rock\nagainst_steel\nagainst_water\nattack\nbase_egg_steps\nbase_happiness\nbase_total\ncapture_rate\nclassfication\ndefense\nexperience_growth\nheight_m\nhp\njapanese_name\nname\npercentage_male\npokedex_number\nsp_attack\nsp_defense\nspeed\ntype1\ntype2\nweight_kg\ngeneration\nis_legendary\n\n\nstr\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\ni64\ni64\ni64\ni64\nstr\nstr\ni64\ni64\nf64\ni64\nstr\nstr\nf64\ni64\ni64\ni64\ni64\nstr\nstr\nf64\ni64\ni64\n\n\n\n\n\"['Beast Boost']\"\n0.25\n1.0\n0.5\n2.0\n0.5\n1.0\n2.0\n0.5\n1.0\n0.25\n0.0\n1.0\n0.5\n0.0\n0.5\n1.0\n0.5\n1.0\n101\n30720\n0\n570\n\"25\"\n\"Launch Pokémon\"\n103\n1250000\n9.2\n97\n\"Tekkaguyaテッカグヤ\"\n\"Celesteela\"\nnull\n797\n107\n101\n61\n\"steel\"\n\"flying\"\n999.9\n7\n1\n\n\n\"['Beast Boost']\"\n1.0\n1.0\n0.5\n0.5\n0.5\n2.0\n4.0\n1.0\n1.0\n0.25\n1.0\n1.0\n0.5\n0.0\n0.5\n0.5\n0.5\n0.5\n181\n30720\n0\n570\n\"255\"\n\"Drawn Sword Pokémon\"\n131\n1250000\n0.3\n59\n\"Kamiturugiカミツルギ\"\n\"Kartana\"\nnull\n798\n59\n31\n109\n\"grass\"\n\"steel\"\n0.1\n7\n1\n\n\n\"['Beast Boost']\"\n2.0\n0.5\n2.0\n0.5\n4.0\n2.0\n0.5\n1.0\n0.5\n0.5\n1.0\n2.0\n1.0\n1.0\n0.0\n1.0\n1.0\n0.5\n101\n30720\n0\n570\n\"15\"\n\"Junkivore Pokémon\"\n53\n1250000\n5.5\n223\n\"Akuzikingアクジキング\"\n\"Guzzlord\"\nnull\n799\n97\n53\n43\n\"dark\"\n\"dragon\"\n888.0\n7\n1\n\n\n\"['Prism Armor']\"\n2.0\n2.0\n1.0\n1.0\n1.0\n0.5\n1.0\n1.0\n2.0\n1.0\n1.0\n1.0\n1.0\n1.0\n0.5\n1.0\n1.0\n1.0\n107\n30720\n0\n600\n\"3\"\n\"Prism Pokémon\"\n101\n1250000\n2.4\n97\n\"Necrozmaネクロズマ\"\n\"Necrozma\"\nnull\n800\n127\n89\n79\n\"psychic\"\nnull\n230.0\n7\n1\n\n\n\"['Soul-Heart']\"\n0.25\n0.5\n0.0\n1.0\n0.5\n1.0\n2.0\n0.5\n1.0\n0.5\n2.0\n0.5\n0.5\n0.0\n0.5\n0.5\n1.0\n1.0\n95\n30720\n0\n600\n\"3\"\n\"Artificial Pokémon\"\n115\n1250000\n1.0\n80\n\"Magearnaマギアナ\"\n\"Magearna\"\nnull\n801\n130\n115\n65\n\"steel\"\n\"fairy\"\n80.5\n7\n1\n\n\n\n\n\n\n\npokemons.describe() # provide some statistical data about dataframe\n\n\nshape: (9, 42)\n\n\n\nstatistic\nabilities\nagainst_bug\nagainst_dark\nagainst_dragon\nagainst_electric\nagainst_fairy\nagainst_fight\nagainst_fire\nagainst_flying\nagainst_ghost\nagainst_grass\nagainst_ground\nagainst_ice\nagainst_normal\nagainst_poison\nagainst_psychic\nagainst_rock\nagainst_steel\nagainst_water\nattack\nbase_egg_steps\nbase_happiness\nbase_total\ncapture_rate\nclassfication\ndefense\nexperience_growth\nheight_m\nhp\njapanese_name\nname\npercentage_male\npokedex_number\nsp_attack\nsp_defense\nspeed\ntype1\ntype2\nweight_kg\ngeneration\nis_legendary\n\n\nstr\nstr\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nstr\nstr\nf64\nf64\nf64\nf64\nstr\nstr\nf64\nf64\nf64\nf64\nf64\nstr\nstr\nf64\nf64\nf64\n\n\n\n\n\"count\"\n\"801\"\n801.0\n801.0\n801.0\n801.0\n801.0\n801.0\n801.0\n801.0\n801.0\n801.0\n801.0\n801.0\n801.0\n801.0\n801.0\n801.0\n801.0\n801.0\n801.0\n801.0\n801.0\n801.0\n\"801\"\n\"801\"\n801.0\n801.0\n781.0\n801.0\n\"801\"\n\"801\"\n703.0\n801.0\n801.0\n801.0\n801.0\n\"801\"\n\"417\"\n781.0\n801.0\n801.0\n\n\n\"null_count\"\n\"0\"\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n\"0\"\n\"0\"\n0.0\n0.0\n20.0\n0.0\n\"0\"\n\"0\"\n98.0\n0.0\n0.0\n0.0\n0.0\n\"0\"\n\"384\"\n20.0\n0.0\n0.0\n\n\n\"mean\"\nnull\n0.996255\n1.057116\n0.968789\n1.07397\n1.068976\n1.065543\n1.135456\n1.192884\n0.985019\n1.03402\n1.098002\n1.208177\n0.887016\n0.975343\n1.005306\n1.250312\n0.983458\n1.058365\n77.857678\n7191.011236\n65.362047\n428.377029\nnull\nnull\n73.008739\n1.0550e6\n1.163892\n68.958801\nnull\nnull\n55.155761\n401.0\n71.305868\n70.911361\n66.334582\nnull\nnull\n61.378105\n3.690387\n0.087391\n\n\n\"std\"\nnull\n0.597248\n0.438142\n0.353058\n0.654962\n0.522167\n0.717251\n0.691853\n0.604488\n0.558256\n0.788896\n0.738818\n0.735356\n0.266106\n0.549375\n0.495183\n0.697148\n0.500117\n0.606562\n32.15882\n6558.220422\n19.598948\n119.203577\nnull\nnull\n30.769159\n160255.835096\n1.080326\n26.576015\nnull\nnull\n20.261623\n231.373075\n32.353826\n27.942501\n28.907662\nnull\nnull\n109.354766\n1.93042\n0.282583\n\n\n\"min\"\n\"['Adaptability', 'Download', '…\n0.25\n0.25\n0.0\n0.0\n0.25\n0.0\n0.25\n0.25\n0.0\n0.25\n0.0\n0.25\n0.0\n0.0\n0.0\n0.25\n0.25\n0.25\n5.0\n1280.0\n0.0\n180.0\n\"100\"\n\"Abundance Pokémon\"\n5.0\n600000.0\n0.1\n1.0\n\"Abagouraアバゴーラ\"\n\"Abomasnow\"\n0.0\n1.0\n10.0\n20.0\n5.0\n\"bug\"\n\"bug\"\n0.1\n1.0\n0.0\n\n\n\"25%\"\nnull\n0.5\n1.0\n1.0\n0.5\n1.0\n0.5\n0.5\n1.0\n1.0\n0.5\n1.0\n0.5\n1.0\n0.5\n1.0\n1.0\n0.5\n0.5\n55.0\n5120.0\n70.0\n320.0\nnull\nnull\n50.0\n1e6\n0.6\n50.0\nnull\nnull\n50.0\n201.0\n45.0\n50.0\n45.0\nnull\nnull\n9.0\n2.0\n0.0\n\n\n\"50%\"\nnull\n1.0\n1.0\n1.0\n1.0\n1.0\n1.0\n1.0\n1.0\n1.0\n1.0\n1.0\n1.0\n1.0\n1.0\n1.0\n1.0\n1.0\n1.0\n75.0\n5120.0\n70.0\n435.0\nnull\nnull\n70.0\n1e6\n1.0\n65.0\nnull\nnull\n50.0\n401.0\n65.0\n66.0\n65.0\nnull\nnull\n27.3\n4.0\n0.0\n\n\n\"75%\"\nnull\n1.0\n1.0\n1.0\n1.0\n1.0\n1.0\n2.0\n1.0\n1.0\n1.0\n1.0\n2.0\n1.0\n1.0\n1.0\n2.0\n1.0\n1.0\n100.0\n6400.0\n70.0\n505.0\nnull\nnull\n90.0\n1.05986e6\n1.5\n80.0\nnull\nnull\n50.0\n601.0\n91.0\n90.0\n85.0\nnull\nnull\n64.8\n5.0\n0.0\n\n\n\"max\"\n\"['Wonder Skin ', 'Magic Guard'…\n4.0\n4.0\n2.0\n4.0\n4.0\n4.0\n4.0\n4.0\n4.0\n4.0\n4.0\n4.0\n1.0\n4.0\n4.0\n4.0\n4.0\n4.0\n185.0\n30720.0\n140.0\n780.0\n\"90\"\n\"Zen Charm Pokémon\"\n230.0\n1.64e6\n14.5\n255.0\n\"Zygarde (10% Forme)ジガルデ\"\n\"Zygarde\"\n100.0\n801.0\n194.0\n230.0\n180.0\n\"water\"\n\"water\"\n999.9\n7.0\n1.0\n\n\n\n\n\n\n\n\nSelecting Columns\nSpecific columns can be selected by column name using the select method. Multiple columns can be selected using a list of column names.\n\ngrades.select('teacher') # select column 'teacher'\n\n\nshape: (4, 1)\n\n\n\nteacher\n\n\nstr\n\n\n\n\n\"Bernoulli\"\n\n\n\"Einstein\"\n\n\n\"Darwin\"\n\n\n\"Laue\"\n\n\n\n\n\n\n\npokemons.select(['name', 'classfication']) # select columns 'name' and 'classfication'\n\n\nshape: (801, 2)\n\n\n\nname\nclassfication\n\n\nstr\nstr\n\n\n\n\n\"Bulbasaur\"\n\"Seed Pokémon\"\n\n\n\"Ivysaur\"\n\"Seed Pokémon\"\n\n\n\"Venusaur\"\n\"Seed Pokémon\"\n\n\n\"Charmander\"\n\"Lizard Pokémon\"\n\n\n\"Charmeleon\"\n\"Flame Pokémon\"\n\n\n…\n…\n\n\n\"Celesteela\"\n\"Launch Pokémon\"\n\n\n\"Kartana\"\n\"Drawn Sword Pokémon\"\n\n\n\"Guzzlord\"\n\"Junkivore Pokémon\"\n\n\n\"Necrozma\"\n\"Prism Pokémon\"\n\n\n\"Magearna\"\n\"Artificial Pokémon\"\n\n\n\n\n\n\n\n\nAdding new columns\nColumns can be added using the method with_columns. The new column(s) can be based on existing columns. The alias method is used to rename the new column.\n\n# Add a column with the sum of 'attack' and 'defense'\n(pokemons\n    .select(['attack', 'defense'])\n    .with_columns((pl.col('attack') + pl.col('defense')).alias('att+def'))\n)\n\n\nshape: (801, 3)\n\n\n\nattack\ndefense\natt+def\n\n\ni64\ni64\ni64\n\n\n\n\n49\n49\n98\n\n\n62\n63\n125\n\n\n100\n123\n223\n\n\n52\n43\n95\n\n\n64\n58\n122\n\n\n…\n…\n…\n\n\n101\n103\n204\n\n\n181\n131\n312\n\n\n101\n53\n154\n\n\n107\n101\n208\n\n\n95\n115\n210\n\n\n\n\n\n\n\n\nSorting\nThe dataframe can be sorted based on the values in a column.\n\ngrades.sort('teacher') # sort by teacher's name\n\n\nshape: (4, 3)\n\n\n\nsubject\ngrade\nteacher\n\n\nstr\nf64\nstr\n\n\n\n\n\"maths\"\n4.5\n\"Bernoulli\"\n\n\n\"biology\"\n5.5\n\"Darwin\"\n\n\n\"physics\"\n5.5\n\"Einstein\"\n\n\n\"chemistry\"\n5.0\n\"Laue\"\n\n\n\n\n\n\n\ngrades.sort('subject', descending=True) # sort by subject name (descending)\n\n\nshape: (4, 3)\n\n\n\nsubject\ngrade\nteacher\n\n\nstr\nf64\nstr\n\n\n\n\n\"physics\"\n5.5\n\"Einstein\"\n\n\n\"maths\"\n4.5\n\"Bernoulli\"\n\n\n\"chemistry\"\n5.0\n\"Laue\"\n\n\n\"biology\"\n5.5\n\"Darwin\"\n\n\n\n\n\n\n\n\nFiltering rows\nSpecific rows can be selected based on a condition using the filter method.\n\ngrades.filter(pl.col('subject') != 'physics') # select all rows where the subject is not physics\n\n\nshape: (3, 3)\n\n\n\nsubject\ngrade\nteacher\n\n\nstr\nf64\nstr\n\n\n\n\n\"maths\"\n4.5\n\"Bernoulli\"\n\n\n\"biology\"\n5.5\n\"Darwin\"\n\n\n\"chemistry\"\n5.0\n\"Laue\"\n\n\n\n\n\n\n\ngrades.filter(pl.col('grade') &gt; 5) # select all rows with grades greater than 5\n\n\nshape: (2, 3)\n\n\n\nsubject\ngrade\nteacher\n\n\nstr\nf64\nstr\n\n\n\n\n\"physics\"\n5.5\n\"Einstein\"\n\n\n\"biology\"\n5.5\n\"Darwin\"\n\n\n\n\n\n\n\n# select all rows where 'attack' is greater than 'defense'\n(pokemons\n    .select(['name', 'attack', 'defense'])\n    .filter(pl.col('attack') &gt; pl.col('defense'))\n)\n\n\nshape: (428, 3)\n\n\n\nname\nattack\ndefense\n\n\nstr\ni64\ni64\n\n\n\n\n\"Charmander\"\n52\n43\n\n\n\"Charmeleon\"\n64\n58\n\n\n\"Charizard\"\n104\n78\n\n\n\"Weedle\"\n35\n30\n\n\n\"Beedrill\"\n150\n40\n\n\n…\n…\n…\n\n\n\"Pheromosa\"\n137\n37\n\n\n\"Xurkitree\"\n89\n71\n\n\n\"Kartana\"\n181\n131\n\n\n\"Guzzlord\"\n101\n53\n\n\n\"Necrozma\"\n107\n101\n\n\n\n\n\n\n\n\nOperations on columns\nThere are many operations acting on the values in a column, e.g. sum, mean, etc.\n\ngrades.select(pl.mean('grade')) # calculate the average grade\n\n\nshape: (1, 1)\n\n\n\ngrade\n\n\nf64\n\n\n\n\n5.125\n\n\n\n\n\n\n\n# calculate the average of 'attack' and the sum of 'defense'\npokemons.select([pl.mean('attack'), pl.sum('defense')])\n\n\nshape: (1, 2)\n\n\n\nattack\ndefense\n\n\nf64\ni64\n\n\n\n\n77.857678\n58480\n\n\n\n\n\n\n\n\nGrouping and aggregating\nData can often be grouped based on the value in one column. Aggregation allows to perform calculations per group.\n\n# dataframe containt grades for four subjects in order of when they were received\ngradebook = pl.DataFrame(\n    {\n        'subject': ['P', 'M', 'C', 'B', 'M', 'C', 'P', 'B', 'M', 'P', 'M', 'C', 'B'],\n        'grade': [5.5, 4.5, 4.5, 5, 5, 4.5, 3.5, 6, 5, 4, 4.5, 5, 5.5]\n    }\n)\n\n# calculate the average per subject\nmean_grades = (gradebook\n .group_by('subject')\n .agg(pl.col('grade').mean())\n)\n\nmean_grades\n\n\nshape: (4, 2)\n\n\n\nsubject\ngrade\n\n\nstr\nf64\n\n\n\n\n\"C\"\n4.666667\n\n\n\"B\"\n5.5\n\n\n\"M\"\n4.75\n\n\n\"P\"\n4.333333\n\n\n\n\n\n\n\n# group by 'type1', then calculate mean attack and defense per group, sort by mean attack\n(pokemons\n    .select(['name', 'type1', 'attack', 'defense'])\n    .group_by('type1')\n    .agg(pl.col('attack').mean(), pl.col('defense').mean())\n    .sort('attack')\n)\n\n\nshape: (18, 3)\n\n\n\ntype1\nattack\ndefense\n\n\nstr\nf64\nf64\n\n\n\n\n\"fairy\"\n62.111111\n68.166667\n\n\n\"psychic\"\n65.566038\n69.264151\n\n\n\"flying\"\n66.666667\n65.0\n\n\n\"bug\"\n70.125\n70.847222\n\n\n\"electric\"\n70.820513\n61.820513\n\n\n…\n…\n…\n\n\n\"rock\"\n90.666667\n96.266667\n\n\n\"steel\"\n93.083333\n120.208333\n\n\n\"ground\"\n94.8125\n83.90625\n\n\n\"fighting\"\n99.178571\n66.392857\n\n\n\"dragon\"\n106.407407\n86.259259\n\n\n\n\n\n\n\n\nPlotting data\nData can be visualised using most plotting libraries. There are some shortcuts built into Polars which are based on Altair (https://altair-viz.github.io/gallery/index.html).\n\n# diagram for the maths grades\n(gradebook\n    .filter(pl.col('subject') == 'M')\n    .with_row_index('test_no', offset=1)\n    .plot.line(\n        x='test_no',\n        y='grade'\n    )\n)\n\n\n\n\n\n\n\n\nimport altair as alt\n\n# For a nicer version we make use of the underlying library's (Altair) more advanced formatting options\nM_grades = (gradebook\n    .filter(pl.col('subject') == 'M')\n    .with_row_index('test_no', offset=1)\n           )\n\nalt.Chart(M_grades).mark_line().encode(\n    alt.Y('grade:Q').scale(domain=(3, 6)),\n    x='test_no',\n)\n\n\n\n\n\n\n\n\n# histogram for the different type1 options\n(pokemons\n .select('type1')\n .group_by('type1')\n .agg(pl.len().alias('frequency'))\n .plot.bar(\n     x='type1',\n     y='frequency'\n )\n)",
    "crumbs": [
      "Polars",
      "Polars"
    ]
  },
  {
    "objectID": "pint/charged_sphere.html",
    "href": "pint/charged_sphere.html",
    "title": "Charged Sphere",
    "section": "",
    "text": "from pint import UnitRegistry\nfrom scipy.constants import electron_mass, elementary_charge\n\n\nureg = UnitRegistry()\n\nQ = ureg('-73 nC')\ne = elementary_charge * ureg('C')\nme = electron_mass * ureg('kg')\n\nNe = Q/(-e)\ndm = Ne * me\n\nprint(f'number of electrons: {Ne.to_base_units():.2e~P}')\nprint(f'mass transfer: {dm.to_base_units():.2e~P}')\n\nnumber of electrons: 4.56×10¹¹\nmass transfer: 4.15×10⁻¹⁹ kg"
  },
  {
    "objectID": "numpy/vectorfields.html",
    "href": "numpy/vectorfields.html",
    "title": "Vector Fields",
    "section": "",
    "text": "Vector fields are an important concept in physics. Typical examples are the gravitational field, electric and magnetic fields.\nIn a vector field, vectors is attached to each point in space.\n\nImports\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n\n\nMeshgrid\nA meshgrid defines the points in space where we want to visualize the vectors.\n\n# create 2D meshgrid\nx, y = np.meshgrid(np.linspace(-10, 10, 20), np.linspace(-10, 10, 20))\n\n# x contains the x coordinates of all 11x11 points, y contains the y coordinates\n\n\n\nQuiver Plot\nA quiver plot adds a vector to each point of a meshgrid.\n\n# uniform field in the positive x direction\nu = 1 # x component of vectors\nv = 0 # y component of vectors\n\nplt.quiver(x, y, u, v)\nplt.gca().set_aspect('equal')\nplt.xlabel('x')\nplt.ylabel('y')\nplt.show()\n\n\n\n\n\n\n\n\n\n# circular field\nr = np.sqrt(x**2 + y**2) # distance to origin\n\n# initialize u and v with zeros\nu = np.zeros_like(x, dtype=float)\nv = np.zeros_like(y, dtype=float)\n\n#create a mask for values with r &gt; 2\nmask = r &gt; 2\n\n#calculate vectors for masked points\nnp.divide(y, r**2, out=u, where=mask) # x component of vector; ignore vectors wit r &lt; 3\nnp.divide(-x, r**2, out=v, where=mask) # y component of vector\n\nplt.quiver(x, y, u, v)\nplt.gca().set_aspect('equal')\nplt.xlabel('x')\nplt.ylabel('y')\nplt.show()\n\n\n\n\n\n\n\n\n\n\n3D Vector Fields\nVector fields in 3D work in the same way, just with an extra dimension.\n\n# define 3D meshgrid\nx, y, z = np.meshgrid(np.linspace(-10, 10, 10), np.linspace(-10, 10, 10), np.linspace(-10, 10, 11))\n\n\n# define vectors\nu = x\nv = y\nw = z\n\nax = plt.figure().add_subplot(projection='3d')\n\nax.quiver(x, y, z, u, v, w, length=0.7, normalize=True) # normalize lengths, i.e. only direction relevant\nplt.show()",
    "crumbs": [
      "NumPy",
      "Vector Fields"
    ]
  },
  {
    "objectID": "numpy/interpolation.html",
    "href": "numpy/interpolation.html",
    "title": "Interpolation",
    "section": "",
    "text": "Physical properties may depend on other parameters like pressure or ambient temperature. While some values can be read from tables (e.g. density of water at different temperatures), if a specific parameter value is required, we often have to interpolate between two tabulated values. NumPy offers a simple method for linear interpolation.\n\nimport numpy as np\n\n\nInterpolating values\nFor numpy.interp() to work correctly, the x values have to be monotonically increasing.\n\nx = np.array([1, 2, 3, 4, 5]) # array of x values (monotonically increasing)\ny = np.array([2, 5, 6, 5, 3]) # array of y values\n\ntest_values = [0.5, 1.5, 3.2, 5.5] # x values to use for interpolation\n\nnp.interp(test_values, x, y) # return interpolated values at positions 'test_values'\n\narray([2. , 3.5, 5.8, 3. ])\n\n\nAs can be seen above, if an x value is less/greater than the minimum/maximum value of the given data, the return value corresponds to the first/last y value.\n\n\nExample: Density of water\nThe table on page 192 in Formulae, Tables, Concepts lists the density of water at various temperatures. What are the answers to the following questions? - What is the density of water at 125°C? - At what temperature is the density of water 900 kg/m^3? - At what temperature is the density of water 999.5 kg/m^3?\n\nData from table\n\ntemperature = np.array([-10, -5, 0, 3, 4, 5, 10, 15, 20,\n                        25, 30, 40, 50, 60, 70, 80, 90,\n                        100, 150, 200, 250, 300, 350])\n\ndensity = np.array([998.109, 999.255, 999.840, 999.964, 999.972,\n                    999.964, 999.700, 999.101, 998.206, 997.047, \n                    995.650, 992.22, 988.04, 983.20, 977.76, \n                    971.79, 965.30, 958.35, 916.8, 864.7,\n                    799.2, 712.2, 574.3])\n\n\n\nDensity at 125°C\n\ntest_temp = 125\ntest_dens = np.interp(test_temp, temperature, density)\nprint(f'density at {test_temp} °C: {test_dens:.1f} kg/m^3')\n\ndensity at 125 °C: 937.6 kg/m^3\n\n\n\n\nTemperature for density 900 kg/m^3\nBefore we can use interp(), we have to sort both the temperature and the density array such that the densities are monotonically increasing.\n\nordered = np.argsort(density)\n\nsorted_dens = density[ordered]\nsorted_temp = temperature[ordered]\n\ntest_dens = 900\ntest_temp = np.interp(test_dens, sorted_dens, sorted_temp)\nprint(f'temperature for {test_dens} kg/m^3: {test_temp:.1f} °C')\n\ntemperature for 900 kg/m^3: 166.1 °C\n\n\n\n\nTemperature for density 999.5 kg/m^3\nBecause of the anomaly of water, there is no one-to-one correspondence between temperature and density around 4 °C. We have to pick the relevant part of the table before the interpolation.\n\ntest_dens = 999.5\ntest_temp1 = np.interp(test_dens, density[:5], temperature[:5]) # only use values up to 4°C\nprint(f'temperature for {test_dens} kg/m^3: {test_temp1:.1f} °C')\n\ntemperature for 999.5 kg/m^3: -2.9 °C\n\n\n\n# For the second solution, we need to consider temperatures above 4 °C. \n# The order of the density values has to be reversed.\ntest_temp2 = np.interp(test_dens, density[-1:3:-1], temperature[-1:3:-1])\nprint(f'temperature for {test_dens} kg/m^3: {test_temp2:.1f} °C')\n\ntemperature for 999.5 kg/m^3: 11.7 °C\n\n\n\n\nVisualisation\n\nimport matplotlib.pyplot as plt\n\nplt.plot(temperature[:9], density[:9], label='density of water')\nplt.xlabel('Temperature (°C)')\nplt.ylabel('Density ' + r'(kg/m$^3$)')\nplt.hlines(test_dens, -10, 20, 'red', label=r'$p$ = ' + f'{test_dens} ' + r'kg/m$^3$')\nplt.plot([test_temp1, test_temp2], [test_dens, test_dens], 'og')\nplt.legend()\nplt.grid()\nplt.show()",
    "crumbs": [
      "NumPy",
      "Interpolation"
    ]
  },
  {
    "objectID": "numpy/broadcasting.html",
    "href": "numpy/broadcasting.html",
    "title": "NumPy Broadcasting",
    "section": "",
    "text": "Broadcasting is a powerful mechanism that allows NumPy to work with arrays of different shapes when performing arithmetic operations.",
    "crumbs": [
      "NumPy",
      "NumPy Broadcasting"
    ]
  },
  {
    "objectID": "numpy/broadcasting.html#the-broadcasting-rule",
    "href": "numpy/broadcasting.html#the-broadcasting-rule",
    "title": "NumPy Broadcasting",
    "section": "The Broadcasting Rule",
    "text": "The Broadcasting Rule\nIn order to broadcast, the size of the trailing axes for both arrays in an operation must either be the same size or one of them must be one.\n\nimport numpy as np\n\n\nExample 1: Scalar and an array\n\na = np.array([1.0, 2.0, 3.0])\nb = 2.0\na * b\n\narray([2., 4., 6.])\n\n\n\n\nExample 2: Mismatched dimensions\n\na = np.array([[ 0.0,  0.0,  0.0],\n               [10.0, 10.0, 10.0],\n               [20.0, 20.0, 20.0],\n               [30.0, 30.0, 30.0]])\nb = np.array([1.0, 2.0, 3.0])\na + b\n\narray([[ 1.,  2.,  3.],\n       [11., 12., 13.],\n       [21., 22., 23.],\n       [31., 32., 33.]])",
    "crumbs": [
      "NumPy",
      "NumPy Broadcasting"
    ]
  },
  {
    "objectID": "numpy/broadcasting.html#reshaping-arrays",
    "href": "numpy/broadcasting.html#reshaping-arrays",
    "title": "NumPy Broadcasting",
    "section": "Reshaping Arrays",
    "text": "Reshaping Arrays\nThe reshape method allows you to change the shape of an array without changing its data. This is often used to prepare arrays for broadcasting.\n\na = np.arange(6)\nprint(f'Original array: {a}')\nb = a.reshape((2, 3))\nprint(f'Reshaped array:\n{b}')\n\n\n  Cell In[4], line 4\n    print(f'Reshaped array:\n          ^\nSyntaxError: unterminated f-string literal (detected at line 4)\n\n\n\n\n\nExample 3: Normalizing Data\nBroadcasting is very useful for standardizing or normalizing data. For example, you can subtract the mean and divide by the standard deviation for each feature in a dataset.\nIn this example, X is a (5, 3) array representing 5 data points with 3 features each. We calculate the mean (X_mean) and standard deviation (X_std) along axis=0, which gives us the mean and standard deviation for each column (feature). Both X_mean and X_std are 1D arrays of shape (3,).\nWhen we execute X - X_mean, NumPy sees that the shapes (5, 3) and (3,) are not the same. It then applies the broadcasting rule: it “stretches” X_mean across the rows of X, effectively subtracting the column’s mean from every element in that column. The same process happens for the division with X_std. This allows us to normalize the entire dataset in a single, readable line of code.\n\nX = np.random.rand(5, 3) * 10\nprint(f'Original data: {X}')\nX_mean = X.mean(axis=0)\nX_std = X.std(axis=0)\nX_normalized = (X - X_mean) / X_std\nprint(f'Normalized data: {X_normalized}')\n\n\n\nExample 4: Creating a Distance Matrix\nYou can use broadcasting to efficiently compute the distance between every pair of points in a dataset.\nHere, we want to compute the Euclidean distance between every pair of points in the points array. A naive approach would use nested loops, which is slow in Python. A broadcasted solution is much faster.\n\nWe start with a points array of shape (4, 2).\nWe use np.newaxis to create two new views of the data: points_row with shape (4, 1, 2) and points_col with shape (1, 4, 2).\nWhen we subtract them (points_row - points_col), NumPy broadcasts the two arrays into a resulting array of shape (4, 4, 2). This new array contains the vector differences between every possible pair of points.\nWe then square the differences, sum along the last axis (axis=2) to get the squared Euclidean distance, and finally take the square root to get the final distance matrix.\n\n\npoints = np.array([[0, 0], [1, 2], [3, 1], [4, 4]])\n# Prepare the points for broadcasting\npoints_row = points[:, np.newaxis, : ]\npoints_col = points[np.newaxis, :, : ]\ndistances = np.sqrt(np.sum((points_row - points_col)**2, axis=2))\nprint(f'Distance matrix: {distances}')",
    "crumbs": [
      "NumPy",
      "NumPy Broadcasting"
    ]
  },
  {
    "objectID": "matplotlib/matplotlib.html",
    "href": "matplotlib/matplotlib.html",
    "title": "Matplotlib",
    "section": "",
    "text": "There are a variety of Python libraries to visualise data. We are going to have a look at the most popular option matplotlib (https://matplotlib.org/).\n\nImport Libraries\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n\n\nGraph of a function\nIn order to graph a function, we have to define values for the horizontal axis.\n\nx = np.linspace(-2*np.pi, 2*np.pi, 1000) # Generate 1000 points from -2π to 2π\nf = np.cos(x)  # Calculate cos(x) for each x\ng = np.sin(x)  # Calculate sin(x) for each x\n\nfig, ax = plt.subplots(figsize=(8, 6)) # Define figure and axis, set size\nax.plot(x, f, label=r'$f(x) = \\cos(x)$', color='blue') # Plot f(x)\nax.plot(x, g, label=r'$g(x) = \\sin(x)$', color='orange') # Plot g(x)\nax.axhline(0, color='black', lw=0.5, ls='--')  # Horizontal line at y=0\nax.axvline(0, color='black', lw=0.5, ls='--')  # Vertical line at x=0\nax.set_xlabel('x') # Set x-axis label\nax.set_ylabel('$f(x)$, $g(x)$') # Set y-axis label\nax.set_title(r'Graph of $\\cos(x)$ and $\\sin(x)$') # Set title\nax.grid(True) # Show grid\nax.legend() # Show legend\nplt.show()  # Display the plot\n\n\n\n\n\n\n\n\n\n\nGraph data\nData points can be graphed using lists or arrays containing the x and y coordinates.\n\nt = [0.0, 0.5, 1.0, 1.5, 2.0, 2.5]  # Example time points\nx = [1.3, 2.8, 3.4, 4.1, 4.5, 4.7]  # Example position points\n\nfig, ax = plt.subplots(figsize=(8, 6)) # Define figure and axis, set size\n# Scatter plot of measured data\nax.scatter(t, x, label='measured data', color='blue', s=10)\nax.set_xlabel('time (s)')\nax.set_ylabel('position (m)')\nax.grid(True) # Show grid\nplt.show()  # Display the plot\n\n\n\n\n\n\n\n\n\n\nArrays of plots\nSeveral plots can be arranged in a gridlike array. This is especially useful if two plots have the same x or y axis.\n\nt = [0, 1, 2, 3, 4, 5]\nx1 = [1, 2, 5, 10, 17, 26]\nx2 = [10, 9, 6, 1, -6, -15]\n\n# set up figure\n# 2 rows, 1 column, shared x axis\nfig, (ax1, ax2) = plt.subplots(nrows=2, ncols=1, sharex=True)\nplt.suptitle('Title') # title for whole figure\nplt.xlabel('$t$') # label for common x axis\n\n# set up plot 1\nax1.scatter(t, x1)\nax1.set_ylabel(r'$x_1$')\nax1.grid(True)\n\n# set up plot 2\nax2.scatter(t, x2)\nax2.set_ylabel(r'$x_2$')\nax2.grid(True)\n\nplt.show()\n\n\n\n\n\n\n\n\n\nError bars\nWhen plotting measured data, it is good practice to add error bars to the data points to indicate the uncertainty of the measured values. This can be done using the plt.errorbar() method.\n\n\nVisualise data and model\n\nt = [0.0, 0.5, 1.0, 1.5, 2.0, 2.5]  # Example time points\ndt = 0.05  # Example time error (same for all points)\n\nx = [1.3, 2.8, 3.4, 4.1, 4.5, 4.7]  # Example position points\ndx = [0.05, 0.05, 0.10, 0.10, 0.15, 0.15]  # Example position errors\n\nfig, ax = plt.subplots(figsize=(8, 6)) # Define figure and axis, set size\n# Scatter plot with error bars\nax.errorbar(t, x, xerr=dt, yerr=dx, \n            label='measured data', \n            fmt='.', \n            color='blue'\n            )\nax.set_xlabel('time (s)')\nax.set_ylabel('position (m)')\nax.grid(True)\nplt.show()",
    "crumbs": [
      "Matplotlib",
      "Matplotlib"
    ]
  },
  {
    "objectID": "numpy/arrays.html",
    "href": "numpy/arrays.html",
    "title": "NumPy Arrays",
    "section": "",
    "text": "NumPy (https://numpy.org/) is the de facto standard for numerical calculations in Python. It can efficiently perform calculations with large data series, matrices, vectors, etc.\nThis notebook provides an overview of arrays, the fundamental data structure used in NumPy. Arrays are similar to lists in Python. Each value in an array has to be of the same type, usually a numerical type like float or integer. Arrays allow for very fast calculations, even if the number of values becomes very large.\n\nImport NumPy\n\nimport numpy as np\n\n\n\nCreate numpy arrays\nThere is a variety of ways how an array can be created.\n\n# create array from list\na_list = [3, 1, 4, 1, 5]\na = np.array(a_list)\nprint(f'{a = }')\n\n# read array from csv file\nb = np.loadtxt('data/data.csv', delimiter=',')\nprint(f'{b = }')\n\n# create array with zeros\ne = np.zeros(10)\nprint(f'{e = }')\n\n# create array with arbitrary value\nv = np.ones(10) * 5.3\nprint(f'{v = }')\n\n# create range of values (with start value and step size, similar to range)\nr = np.arange(10, 15.5, .5)\nprint(f'{r = }')\n\n# create evenly spaced values between min and max value\nx = np.linspace(100, 200, 11)\nprint(f'{x = }')\n\na = array([3, 1, 4, 1, 5])\nb = array([31., 41., 46., 91., 53., 76., 59., 97., 48., 14., 83., 77., 34.,\n       89., 65., 21., 95., 66., 44., 40., 38., 27., 41.,  1., 61., 19.,\n       22., 79., 14., 97., 48., 73., 44., 74., 53., 51., 14., 19., 52.,\n       85., 13., 25., 91.,  5.,  5., 86., 22., 72., 68., 60.])\ne = array([0., 0., 0., 0., 0., 0., 0., 0., 0., 0.])\nv = array([5.3, 5.3, 5.3, 5.3, 5.3, 5.3, 5.3, 5.3, 5.3, 5.3])\nr = array([10. , 10.5, 11. , 11.5, 12. , 12.5, 13. , 13.5, 14. , 14.5, 15. ])\nx = array([100., 110., 120., 130., 140., 150., 160., 170., 180., 190., 200.])\n\n\n\n\nSlicing arrays\nSlicing can be used to extract a part of an array. This is very similar to slicing of lists in Python.\n\na[2] # access element with index 2 (first element has index 0)\n\nnp.int64(4)\n\n\n\na[-2] # access second to last element\n\nnp.int64(1)\n\n\n\na[1:4] # subarray from index 1 to index 3 (upper boundary excluded)\n\narray([1, 4, 1])\n\n\n\n\nBoolean Indexing\nYou can use a boolean array to select elements from another array. The boolean array must have the same shape as the array you’re indexing.\n\na = np.array([[1, 2], [3, 4], [5, 6]])\nbool_idx = a &gt; 2\nprint(bool_idx)\nprint(a[bool_idx])\n\n[[False False]\n [ True  True]\n [ True  True]]\n[3 4 5 6]\n\n\n\n\nFancy Indexing\nFancy indexing is indexing that uses an array of indices to access multiple array elements at once.\n\na = np.array([10, 20, 30, 40, 50, 60, 70])\nindices = [1, 3, 5]\nprint(a[indices])\n\n[20 40 60]\n\n\n\n\nCalculate with arrays\n\na**2 # operations are calculated element wise\n\narray([ 100,  400,  900, 1600, 2500, 3600, 4900])\n\n\n\nnp.sqrt(x) # numpy provides many mathematical functions\n\narray([10.        , 10.48808848, 10.95445115, 11.40175425, 11.83215957,\n       12.24744871, 12.64911064, 13.03840481, 13.41640786, 13.78404875,\n       14.14213562])\n\n\n\nr * x # calculations with arrays of same length\n\narray([1000., 1155., 1320., 1495., 1680., 1875., 2080., 2295., 2520.,\n       2755., 3000.])\n\n\n\nnp.sum(b) # sum of all elements in array\n\nnp.float64(2529.0)\n\n\n\nnp.mean(b) # mean value\n\nnp.float64(50.58)\n\n\n\n\nSpeed comparison between NumPy arrays and lists\n\n%%timeit\n\n# create a large array and sum its elements\nlarge_array = np.arange(1_000_000)\n\nnp.sum(large_array)\n\n687 μs ± 84.9 μs per loop (mean ± std. dev. of 7 runs, 1,000 loops each)\n\n\n\n%%timeit\n\n# create a large list and sum its elements\nlarge_list = range(1_000_000)\nsum(large_list)\n\n12.1 ms ± 1.42 ms per loop (mean ± std. dev. of 7 runs, 100 loops each)\n\n\n\n\nExample: Free fall\nPerform some calculations for a free-fall motion.\n\ng = 10 # define gravitational acceleration in m/s^2\n\nt = np.arange(0, 1, 0.1) # time array\ns = 0.5 * g * t**2 # calculate distance for free fall\n\nds = np.diff(s) # calculate distance difference between time steps\nprint(f'{ds = }') # as expected, the distance difference is linearly increasing\n\ndds = np.diff(ds) # calculate second difference\nprint(f'{dds = }') # as expected, the second difference is constant (equal to g dt^2)\n\nds = array([0.05, 0.15, 0.25, 0.35, 0.45, 0.55, 0.65, 0.75, 0.85])\ndds = array([0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1])\n\n\n\nExample: Temperature data\nPerform some simple calculations based on temperature data. You may want to compare the data for 2024 with the data for 1924 in the same folder.\n\npath = 'data/zrh_temp_2024.csv' # file containing daily average temperatures for 2024\ntemperature = np.loadtxt(path, skiprows=1) # create array from textfile, skip header\n\n\nn = len(temperature) # number of entries\nt_min = np.min(temperature)\nt_max = np.max(temperature)\nt_mean = np.mean(temperature)\nt_std = np.std(temperature)\n\nprint(f'number of data points: {n}')\nprint(f'minimum temperature: {t_min}°C')\nprint(f'maximum temperature: {t_max}°C')\nprint(f'yearly mean temperature: {t_mean:.2f}°C')\nprint(f'standard deviation: {t_std:.2f}°C')\n\nnumber of data points: 366\nminimum temperature: -5.2°C\nmaximum temperature: 24.9°C\nyearly mean temperature: 11.04°C\nstandard deviation: 7.05°C",
    "crumbs": [
      "NumPy",
      "NumPy Arrays"
    ]
  },
  {
    "objectID": "numpy/data_analysis.html",
    "href": "numpy/data_analysis.html",
    "title": "Data Analysis with NumPy",
    "section": "",
    "text": "import numpy as np"
  },
  {
    "objectID": "numpy/data_analysis.html#example-measuring-density",
    "href": "numpy/data_analysis.html#example-measuring-density",
    "title": "Data Analysis with NumPy",
    "section": "Example: Measuring density",
    "text": "Example: Measuring density\nSix students measure mass and side of the same brass cube. They end up with slightly different values. The measured data is listed below. How can we efficiently calculate the densities resulting from this data?\n\nDefine arrays for measured data\n\nm = np.array([69.3, 69.1, 69.0, 69.0, 69.2, 69.2]) # mass in g\na = np.array([2.05, 2.00, 2.05, 1.95, 2.00, 2.00]) # side in cm\n\n\n\nFind some characteristic values\n\nm_max = np.max(m)\nm_min = np.min(m)\nm_mean = np.mean(m)\nprint(f'max: {m_max} g, min: {m_min} g, mean: {m_mean:.2f} g')\n\n\n\nCalculate volumes and densities\n\nV = a**3\nrh = m/V\nprint(f'densities: {rh}')\n\n\n\nMean value and deviations\n\nrh_mean = np.mean(rh)\nrh_dev_max = np.max(rh)-rh_mean\nrh_dev_min = rh_mean-np.min(rh)\nprint(f'mean density: {rh_mean:.1f} g/cm^3')\nprint(f'deviation max-mean: {rh_dev_max:.1f} g/cm^3')\nprint(f'deviation min-mean: {rh_dev_min:.1f} g/cm^3')\n\n\n\nError calculation\nAll students measured the same quantities on the same cube. In this case we make an estimate for the measurement errors for mass and side length based on the deviations between the different students.\n\ndm = 0.2 # error for mass in g\nda = 0.05 # error for side in cm\n\nThe error for the density can be found using the “worst case method”.\n\nrh = m_mean/np.mean(a)**3 # mean density (based on mean mass and mean side)\nrh_max = (m_mean+dm)/(np.mean(a)-da)**3 # max density (based on max mass and min side)\ndrh = rh_max - rh # error\n\n\nprint(f'density: ({rh:.1f} ± {drh:.1f}) g/cm^3')\n\n\n\nCalculation with Pint\nAlternatively, we can use the built-in functionality of Pint to calculate the values, including their errors.\n\nfrom pint import UnitRegistry\nfrom uncertainties import unumpy\n\nureg = UnitRegistry()\n\nm = np.array([69.3, 69.1, 69.0, 69.0, 69.2, 69.2]) # mass in g\na = np.array([2.05, 2.00, 2.05, 1.95, 2.00, 2.00]) # side in cm\n\nm = (m * ureg.gram) # convert to Pint quantities\nm = np.array([m_i.plus_minus(0.2 * ureg.gram) for m_i in m]) # add uncertainty\n\na = (a * ureg.centimeter) # convert to Pint quantities\na = np.array([a_i.plus_minus(0.05 * ureg.centimeter) for a_i in a]) # add uncertainty\n\nV_p = a**3 # calculate volume\nrh_p = m/V_p # calculate density\n\nprint(f'density: {rh_p.mean():~P}')\n\n\nRemark\nThe uncertainty calculated by Pint takes into account that the uncertainty of the mean value of independent measurements is smaller than the error of a single measurement. According to the rules of error calculation, the uncertainty of the mean is\n\\[\\Delta \\bar{x} = \\frac{\\Delta x}{\\sqrt{N}}\\]\nwhere \\(N\\) is the number of measurements."
  },
  {
    "objectID": "numpy/random.html",
    "href": "numpy/random.html",
    "title": "NumPy Random Module",
    "section": "",
    "text": "The numpy.random module provides functions for working with random numbers.\nimport numpy as np\nimport matplotlib.pyplot as plt",
    "crumbs": [
      "NumPy",
      "NumPy Random Module"
    ]
  },
  {
    "objectID": "numpy/random.html#generating-random-data",
    "href": "numpy/random.html#generating-random-data",
    "title": "NumPy Random Module",
    "section": "Generating Random Data",
    "text": "Generating Random Data\nYou can generate arrays of random numbers from various distributions.\n\n# Generate a 2x3 array of random floats between 0 and 1\nprint(np.random.rand(2, 3))\n\n# Generate a 2x3 array of random integers between 1 and 10\nprint(np.random.randint(1, 10, size=(2, 3)))\n\n[[0.28240849 0.67075463 0.24297965]\n [0.84532407 0.33236114 0.01213815]]\n[[5 9 9]\n [9 1 2]]",
    "crumbs": [
      "NumPy",
      "NumPy Random Module"
    ]
  },
  {
    "objectID": "numpy/random.html#shuffling-arrays",
    "href": "numpy/random.html#shuffling-arrays",
    "title": "NumPy Random Module",
    "section": "Shuffling Arrays",
    "text": "Shuffling Arrays\nYou can randomly shuffle the elements of an array.\n\na = np.arange(10)\nnp.random.shuffle(a)\nprint(a)\n\n[1 3 2 5 7 9 0 6 4 8]\n\n\n\nExample: Simulating Dice Rolls\nWe can simulate rolling a fair six-sided die multiple times.\n\nrolls = np.random.randint(1, 7, size=100)\nprint(f'First 10 rolls: {rolls[:10]}')\n# Count the occurrences of each outcome\ncounts = np.bincount(rolls)[1:]\nprint(f'Counts for each outcome (1-6): {counts}')\n\nFirst 10 rolls: [4 2 3 6 3 5 6 1 3 2]\nCounts for each outcome (1-6): [19 17 18  8 15 23]\n\n\n\n\nExample: Sampling from a Normal Distribution\nIn many scientific applications, you need to draw samples from a specific statistical distribution, like the normal (Gaussian) distribution.\n\nmu, sigma = 0, 0.1 # mean and standard deviation\nsamples = np.random.normal(mu, sigma, 1000)\n# Plot a histogram of the samples\nplt.hist(samples, bins=30, density=True)\nplt.title('Samples from a Normal Distribution')\nplt.show()",
    "crumbs": [
      "NumPy",
      "NumPy Random Module"
    ]
  },
  {
    "objectID": "numpy/random.html#reproducible-randomness-with-seeding",
    "href": "numpy/random.html#reproducible-randomness-with-seeding",
    "title": "NumPy Random Module",
    "section": "Reproducible Randomness with Seeding",
    "text": "Reproducible Randomness with Seeding\nFor scientific experiments and debugging, it’s crucial to have reproducible results. You can achieve this by setting a “seed” for the random number generator. The same seed will always produce the same sequence of random numbers.\n\nnp.random.seed(42) # Set the seed\nprint(np.random.rand(5))\nnp.random.seed(42) # Reset the seed\nprint(np.random.rand(5))\n\n[0.37454012 0.95071431 0.73199394 0.59865848 0.15601864]\n[0.37454012 0.95071431 0.73199394 0.59865848 0.15601864]",
    "crumbs": [
      "NumPy",
      "NumPy Random Module"
    ]
  },
  {
    "objectID": "numpy/vectors_matrices.html",
    "href": "numpy/vectors_matrices.html",
    "title": "Vectors and Matrices in NumPy",
    "section": "",
    "text": "Vectors\nVectors can be implemented as arrays with 2 (2D vectors) or 3 (3D vectors) elements. Typical vector operations can easily be calculated.\n\nimport numpy as np\n\nu = np.array([1, 3, 2]) # vector u\nv = np.array([3, 2, 4]) # vector v\n\nprint(f'sum: u + v = {u+v}')\nprint(f'difference: u - v = {u-v}')\nprint(f'scalar multiplication: 3 u = {3*u}')\nprint(f'dot product: u · v = {np.dot(u, v)}')\nprint(f'cross product: u x v = {np.cross(u, v)}')\n\nsum: u + v = [4 5 6]\ndifference: u - v = [-2  1 -2]\nscalar multiplication: 3 u = [3 9 6]\ndot product: u · v = 17\ncross product: u x v = [ 8  2 -7]\n\n\nA two-dimensional array (array of vectors) can be used to perform calculations on several vectors at once.\n\nv_list = np.array([[1, 0, 0], [0, 2, 1], [1, 0, 3], [0, 2, 3]])\n\nprint(f'sum of vectors: {np.sum(v_list, axis=0)}')\n\nsum of vectors: [2 4 7]\n\n\nThe keyword argument axis defines the level within the array that is used for the summation. With axis=1 the summation acts on each of the four vectors:\n\nprint(f'sum of components within each vector: {np.sum(v_list, axis=1)}')\n\nsum of components within each vector: [1 3 4 5]\n\n\nIf axis is not defined, the values are added independently of their level.\n\nprint(f'sum of all components: {np.sum(v_list)}')\n\nsum of all components: 13\n\n\n\n\nMatrices\nA two-dimensional array (i.e. a nested array) can also be interpreted as a matrix.\n\nA = np.array([[0, 1, 9], [2, 0, 3], [6, 2, 3]])\nB = np.array([[0, 1, 3], [1, 0, 1], [3, 2, 1]])\nprint(A)\nprint()\nprint(B)\n\n[[0 1 9]\n [2 0 3]\n [6 2 3]]\n\n[[0 1 3]\n [1 0 1]\n [3 2 1]]\n\n\nElements of the matrix can easily be accessed. Bear in mind that indices are zero-based.\n\nprint(f'Element A(1, 2): {A[0, 1]}') # element in first row, second column\n\nElement A(1, 2): 1\n\n\n\nprint(f'second row: {A[1, :]}')\n\nsecond row: [2 0 3]\n\n\n\nprint(f'third column: {A[:, 2]}')\n\nthird column: [9 3 3]\n\n\n\n\nMatrix multiplication\nThe symbol @ is used for matrix multiplication:\n\nprint(A @ B) # product of A and B\nprint()\nprint(A @ u) # A applied to vector u\n\n[[28 18 10]\n [ 9  8  9]\n [11 12 23]]\n\n[21  8 18]\n\n\nThe sub-library numpy.linalg contains additional methods to work with matrices.\n\nfrom numpy.linalg import inv, eig\n\n\n\nInverted matrix\n\nprint(inv(A)) # inverse of matrix A\nprint()\nprint(A @ inv(A)) # should be identity matrix; deviations are due to numerical errors\nprint()\nprint(np.round(A @ inv(A), decimals=5))\n\n[[-0.125       0.3125      0.0625    ]\n [ 0.25       -1.125       0.375     ]\n [ 0.08333333  0.125      -0.04166667]]\n\n[[ 1.00000000e+00  0.00000000e+00  2.08166817e-17]\n [-1.38777878e-17  1.00000000e+00  6.93889390e-18]\n [ 0.00000000e+00  0.00000000e+00  1.00000000e+00]]\n\n[[ 1.  0.  0.]\n [-0.  1.  0.]\n [ 0.  0.  1.]]\n\n\n\n\nEigenvalues and eigenvectors\n\nvalues, matrix = eig(A)\n\nprint(values) # eigenvalues of A\nprint()\nprint(matrix) # eigenvectors of A as a matrix, columns are eigenvectors\n\n[ 9.81507291 -6.         -0.81507291]\n\n[[-6.54194593e-01 -8.32050294e-01  2.67585631e-01]\n [-3.39827915e-01 -6.83846344e-18 -9.60001397e-01]\n [-6.75682190e-01  5.54700196e-01  8.24332888e-02]]\n\n\n\nvectors = matrix.T # eigenvectors correspond to rows of transposed matrix\n\nfor i in range(0, 3):\n    print(np.round(A @ vectors[i] - values[i] * vectors[i], decimals=5)) # verify if A v = \\lambda v\n\n[-0. -0. -0.]\n[ 0. -0. -0.]\n[ 0. -0.  0.]\n\n\n\n\nExample: Solve system of linear equations\nSolve the following system of linear equations:\n\\(x + 2y + 3z = 13\\)\n\\(y - z = -2\\)\n\\(2x - y + z = 6\\)\nThe system can be written as\n\\(M \\begin{pmatrix} x \\\\ y \\\\ z \\end{pmatrix} = \\vec{b}\\)\nwith \\(M = \\begin{pmatrix} 1 & 2 & 3 \\\\ 0 & 1 & -1 \\\\ 2 & -1 & 1 \\end{pmatrix} \\quad\\) and \\(\\quad \\vec{b} = \\begin{pmatrix} 13 \\\\ -2 \\\\ 6 \\end{pmatrix}\\)\nThe solution is then \\(\\begin{pmatrix} x \\\\ y \\\\ z \\end{pmatrix} = M^{-1}\\, \\vec{b}\\)\n\nM = np.array([[1, 2, 3], [0, 1, -1], [2, -1, 1]])\nb = np.array([13, -2, 6])\n\nx, y, z = inv(M) @ b\n\nprint(f'The solution is {x=:.1f}, {y=:.1f}, {z=:.1f}')\n\nThe solution is x=2.0, y=1.0, z=3.0",
    "crumbs": [
      "NumPy",
      "Vectors and Matrices in NumPy"
    ]
  },
  {
    "objectID": "pint/pint.html",
    "href": "pint/pint.html",
    "title": "Pint: Calculations with units",
    "section": "",
    "text": "The library Pint (https://pint.readthedocs.io/en/stable/index.html) allows for simple calculations with units. It is also a very convenient tool for unit conversions.",
    "crumbs": [
      "Pint",
      "Pint: Calculations with units"
    ]
  },
  {
    "objectID": "pint/pint.html#examples",
    "href": "pint/pint.html#examples",
    "title": "Pint: Calculations with units",
    "section": "Examples",
    "text": "Examples\nThe following examples demonstrate how quantities with units can be defined or converted, and how calculated quantities can be formatted.\n\nExample 1: Current\n\nI = ureg('75 mA') # define current in mA\ndt = ureg('4.5 h') # define time interval in h\n\nQ = I * dt # calculate charge\n\n# convert I and dt to basic units before calculating Q\nQ_C = I.to_base_units() * dt.to_base_units()\n\nprint(f'Q = {Q}') # print charge in standard form\nprint(f'Q = {Q:~P.0f}') # print charge nicely formatted with unit symbols\nprint(f'Q = {Q.to('mAh'):~.0f}') # print charge in unit mAh\nprint(f'Q = {Q.to('C'):~P.2e}') # print charge in C\nprint(f'Q = {Q.to('C'):#~P.2f}') # print charge in C using unit prefix\nprint(f'Q = {Q_C:~P.2e} = {Q_C.to('C'):.2e~P}') # print charge (calculated with basic units)\n\nQ = 337.5 hour * milliampere\nQ = 338 h·mA\nQ = 337 mAh\nQ = 1.21×10³ C\nQ = 1.21 kC\nQ = 1.22×10³ A·s = 1.22×10³ C\n\n\n\n\nExample 2: Density\n\nrho = ureg.Quantity(7.92, 'g/cm**3') # define density using Quantity\nV = ureg.Quantity(2.5, 'dl') # define volume\n\nm = rho * V # calculate mass\n\nprint(f'{m:.2f~P}') # print result with \"raw\" units\nprint(f'{m.to_base_units():.2f~P}') # print result in base unit\n\n19.80 dl·g/cm³\n1.98 kg\n\n\n\n\nExample 3: Pressure\n\np = 354 * ureg('mbar') # define pressure in mbar\nA = 442 * ureg('cm**2') # define area in cm^2\n\nF = p * A # calculate force\n\nprint(f'{F:.3g~P}') # print result with \"raw\" units (3 significant figures)\nprint(f'{F.to_base_units():~P.3g}') # print result in base units\nprint(f'{F.to('N'):~P.3g}') # print result in N\nprint(f'{F.to('N'):#~P.3g}') # print result in N (with unit prefix)\n\n1.56×10⁵ cm²·mbar\n1.56×10³ kg·m/s²\n1.56×10³ N\n1.56 kN\n\n\n\n\nUsing Pint together with Uncertainties\nThe libraries Pint and Uncertainties (https://uncertainties.readthedocs.io/en/latest/index.html) can be used together to make calculations with physical quantities including their uncertainties. The uncertainty of a calculated quantity is calculated according to the rules of error calculation, and the result is printed in a standard format.\n\nExample: Density\n\n# Define side and mass of a cube, including uncertainties\na = ureg('1.5 cm').plus_minus(0.05)\nm = ureg('93.3 g').plus_minus(0.1)\n\nprint(f'a = {a:~P}') # print value with uncertainty in standard form\nprint(f'm = {m:~P}')\n\nrho = m / (a**3) # calculate density\n\n# print result with calculated uncertainty\nprint(f'density = {rho.to('kg/m**3'):~P} = {rho.to('g/cm**3'):~P}')\n\na = (1.50 ± 0.05) cm\nm = (93.30 ± 0.10) g\ndensity = (2.76 ± 0.28)×10⁴ kg/m³ = (27.6 ± 2.8) g/cm³",
    "crumbs": [
      "Pint",
      "Pint: Calculations with units"
    ]
  },
  {
    "objectID": "scipy/constants.html",
    "href": "scipy/constants.html",
    "title": "Physical Constants",
    "section": "",
    "text": "The Python library SciPy (https://scipy.org/) contains a collection of important physical constants and units.\n\nImport constants\n\nfrom scipy import constants\n\n\nShow list of constants\nA list of the constants and units in scipy.constants can be found on https://docs.scipy.org/doc/scipy/reference/constants.html.\n\nfor c in dir(constants):\n    print(c)\n\nAvogadro\nBoltzmann\nBtu\nBtu_IT\nBtu_th\nConstantWarning\nG\nJulian_year\nN_A\nPlanck\nR\nRydberg\nStefan_Boltzmann\nWien\n__all__\n__builtins__\n__cached__\n__doc__\n__file__\n__loader__\n__name__\n__package__\n__path__\n__spec__\n_codata\n_constants\n_obsolete_constants\nacre\nalpha\nangstrom\narcmin\narcminute\narcsec\narcsecond\nastronomical_unit\natm\natmosphere\natomic_mass\natto\nau\nbar\nbarrel\nbbl\nblob\nc\ncalorie\ncalorie_IT\ncalorie_th\ncarat\ncenti\ncodata\nconstants\nconvert_temperature\nday\ndeci\ndegree\ndegree_Fahrenheit\ndeka\ndyn\ndyne\ne\neV\nelectron_mass\nelectron_volt\nelementary_charge\nepsilon_0\nerg\nexa\nexbi\nfemto\nfermi\nfind\nfine_structure\nfluid_ounce\nfluid_ounce_US\nfluid_ounce_imp\nfoot\ng\ngallon\ngallon_US\ngallon_imp\ngas_constant\ngibi\ngiga\ngolden\ngolden_ratio\ngrain\ngram\ngravitational_constant\nh\nhbar\nhectare\nhecto\nhorsepower\nhour\nhp\ninch\nk\nkgf\nkibi\nkilo\nkilogram_force\nkmh\nknot\nlambda2nu\nlb\nlbf\nlight_year\nliter\nlitre\nlong_ton\nm_e\nm_n\nm_p\nm_u\nmach\nmebi\nmega\nmetric_ton\nmicro\nmicron\nmil\nmile\nmilli\nminute\nmmHg\nmph\nmu_0\nnano\nnautical_mile\nneutron_mass\nnu2lambda\nounce\noz\nparsec\npebi\npeta\nphysical_constants\npi\npico\npoint\npound\npound_force\nprecision\nproton_mass\npsi\npt\nquecto\nquetta\nronna\nronto\nshort_ton\nsigma\nslinch\nslug\nspeed_of_light\nspeed_of_sound\nstone\nsurvey_foot\nsurvey_mile\ntebi\ntera\ntest\nton_TNT\ntorr\ntroy_ounce\ntroy_pound\nu\nunit\nvalue\nweek\nyard\nyear\nyobi\nyocto\nyotta\nzebi\nzepto\nzero_Celsius\nzetta\n\n\n\n\nUsing constants\n\nprint(f'elementary charge: e = {constants.elementary_charge} C')\nprint(f'electron mass: me = {constants.electron_mass} kg')\n\nelementary charge: e = 1.602176634e-19 C\nelectron mass: me = 9.1093837139e-31 kg\n\n\n\n# convert proton mass to MeV\nmp = constants.m_p # proton mass in kg\nc = constants.speed_of_light # speed of light\nMeV = 1e6 * constants.electron_volt # conversion factor J -&gt; MeV\n\nmp_MeV = mp * c**2 / MeV # convert from kg to MeV/c^2\n\nprint(f'proton mass: mp = {mp_MeV} MeV/c^2')\n\nproton mass: mp = 938.2720894282575 MeV/c^2\n\n\n\n\nAdditional Constants\nThe dictionary physical_constants contains the recommended values (including uncertainties) of a large number of physical constants, as listed in the CODATA database. The return value is a dictionary containing the value, unit, and uncertainty.\n\nm_al, unit, uncertainty = constants.physical_constants['alpha particle mass']\nprint(f'mass of alpha particle: {m_al} {unit} (± {uncertainty} {unit})')\n\nmass of alpha particle: 6.644657345e-27 kg (± 2.1e-36 kg)\n\n\n\n# The speed of light is an exact value in the SI system, so it has no uncertainty.\nc, unit, uncertainty = constants.physical_constants['speed of light in vacuum']\nprint(f'speed of light: {c:.0f} {unit} (± {uncertainty} {unit})')\n\nspeed of light: 299792458 m s^-1 (± 0.0 m s^-1)",
    "crumbs": [
      "SciPy",
      "Physical Constants"
    ]
  },
  {
    "objectID": "scipy/functions.html",
    "href": "scipy/functions.html",
    "title": "Functions",
    "section": "",
    "text": "SciPy (https://scipy.org/) provides methods to efficiently calculate zeros or extrema of functions (numerically). It also knows about a large number of special function used in various areas of mathematics and physics.\n\nFinding root of function\nMany equations cannot be solved analytically, e.g. if trigonometric functions are involved. It is still possible to calculate a numerical solution using an appropriate algorithm.\nAs an example, we are going to find the nontrivial solution for the equation\n\\(\\sin(x) = \\frac{1}{2} x\\)\nThis is equivalent to finding a root (i.e. zero) of the function \\(f(x) = \\sin(x) - \\frac{1}{2}\\)\nIn addition to the function, an initial guess for the root has to be provided (e.g. found from a sketch).\n\nimport matplotlib.pyplot as plt\n\nimport numpy as np\nfrom scipy.optimize import root_scalar\n\n\n# define function\ndef f(x):\n    return np.sin(x) - x/2\n\nsol = root_scalar(f, x0=2) # find root with initial guess x=2\n\nsolx = sol.root\nsoly = solx/2\n\nx = np.linspace(0, np.pi, 100)\ny = np.sin(x)\n\nplt.plot(x, y, label=r'$f(x)=\\sin(x)$')\nplt.plot(x, x/2, label=r'$g(x)=\\frac{x}{2}$')\nplt.scatter(solx, soly, c='red')\nplt.legend()\nplt.grid()\nplt.show()\n\n\n\n\n\n\n\n\n\n\nFinding minimum or maximum\nThe method scipy.fmin() numerically calculates the (local) minimum of a function near an initial guess. The same method can be used to find a maximum if applied to -f(x) instead of f(x).\n\nfrom scipy.optimize import fmin\n\n# define function\ndef g(x):\n    return np.sin(x**2) * np.exp(-x/3)\n\nsol = fmin(g, x0=2, disp=False) # find minimum with initial guess x=2\n\nx_min = sol[0]\ny_min = g(x_min)\n\nx = np.linspace(0, 2*np.pi, 500)\nprint(f'minimum at x={x_min:.3f}, g(x)={y_min:.3f}')\n\nsol2 = fmin(lambda x: -g(x), x0=1, disp=False) # find maximum with initial guess x=1\n\nx_max = sol2[0]\ny_max = g(x_max)\n\nprint(f'maximum at x={x_max:.3f}, g(x)={y_max:.3f}')\n\nplt.plot(x, g(x), label=r'$g(x)$')\nplt.scatter(x_min, y_min, c='green', label='minimum')\nplt.scatter(x_max, y_max, c='red', label='maximum')\nplt.legend()\nplt.grid\nplt.show()\n\nminimum at x=2.153, g(x)=-0.486\nmaximum at x=1.197, g(x)=0.665\n\n\n\n\n\n\n\n\n\n\n\nSpecial functions\nThere are a lot of special functions used in science whose values cannot be calculated easily, e.g. Elliptic functions, Bessel functions, etc.\nAs an example we use a special function in SciPy to calculate the area under the Gaussian function (normal distribution):\n\\(P(x) = \\frac{1}{\\sqrt{2\\pi}} \\int_{-\\infty}^x \\exp(-t^2/2) dt\\)\n\nfrom scipy.special import ndtr\n\nprint(f'A(0.5) = {ndtr(-0.2)}')\n\nA = ndtr(1) - ndtr(-1) # area between x1 = -1 and x2 = +1\nprint(f'area between -1 and 1: A = {A}') # (corresponds to ± 1 standard deviation)\n\nA(0.5) = 0.42074029056089696\narea between -1 and 1: A = 0.6826894921370859",
    "crumbs": [
      "SciPy",
      "Functions"
    ]
  },
  {
    "objectID": "sympy/calculus.html",
    "href": "sympy/calculus.html",
    "title": "Calculus (Symbolic)",
    "section": "",
    "text": "SymPy contains methods to analytically determine derivatives and integrals of functions.\n\nimport sympy as sp\n\n\nDerivatives\nThe diff function can be used to take derivates of functions.\n\nx = sp.Symbol('x')\nf = sp.cos(x) + sp.tan(x)\ndf = sp.diff(f, x)\ndisplay(f, df)\n\n\\(\\displaystyle \\cos{\\left(x \\right)} + \\tan{\\left(x \\right)}\\)\n\n\n\\(\\displaystyle - \\sin{\\left(x \\right)} + \\tan^{2}{\\left(x \\right)} + 1\\)\n\n\n\ng = x**2+3*x-1\ndg = sp.diff(g, x)\ndisplay(g, dg)\n\n\\(\\displaystyle x^{2} + 3 x - 1\\)\n\n\n\\(\\displaystyle 2 x + 3\\)\n\n\n\nh = sp.exp(-x**2/2)\ndh = sp.diff(h, x)\ndisplay(h, dh)\n\n\\(\\displaystyle e^{- \\frac{x^{2}}{2}}\\)\n\n\n\\(\\displaystyle - x e^{- \\frac{x^{2}}{2}}\\)\n\n\n\n\nIndefinite integrals\nIndefinite integrals can be computed with the integrate function. The additive constant is not shown in the output.\n\nsp.integrate(sp.sin(x), x)\n\n\\(\\displaystyle - \\cos{\\left(x \\right)}\\)\n\n\n\nf = sp.log(x)\nsp.integrate(f, x)\n\n\\(\\displaystyle x \\log{\\left(x \\right)} - x\\)\n\n\n\n\nDefinite Integrals\nFor definite integrals, the lower and upper boundary are passed to the integrate function as additional parameters.\n\nsp.integrate(sp.cos(x)**2, (x, 0, 2*sp.pi))\n\n\\(\\displaystyle \\pi\\)\n\n\n\nf = sp.exp(-x**2) # Gaussian function\nsp.integrate(f, (x, 0, sp.oo)) # upper limit is infinity\n\n\\(\\displaystyle \\frac{\\sqrt{\\pi}}{2}\\)",
    "crumbs": [
      "SymPy",
      "Calculus (Symbolic)"
    ]
  },
  {
    "objectID": "sympy/expressions.html",
    "href": "sympy/expressions.html",
    "title": "Symbolic Calculations with SymPy",
    "section": "",
    "text": "SymPy (https://www.sympy.org/en/index.html) is a Python library for symbolic mathematics. It can be used to simplify expressions, find formal solutions of equations, or derive or integrate functions.\n\nImport SymPy\n\nimport sympy as sp\n\n\n\nSymbols\nBefore symbols like \\(x\\), \\(y\\), \\(a\\), \\(b\\), etc. can be used in expressions, they have to be defined.\n\nx = sp.Symbol('x') # define a single symbol\ny, z = sp.symbols('y z') # define multiple symbols\n\nr = sp.Symbol('p', real=True) # define a real quantity (as opposed to a complex one)\np = sp.Symbol('p', positive=True) # define a positive quantity\n\ndisplay((x + y)/z) # display expression containing symbols\n\n\\(\\displaystyle \\frac{x + y}{z}\\)\n\n\n\n\nExpressions\nExpressions contain symbols, functions and numerical constants. They can be simplified, expanded or factored.\n\nexp1 = (x + y) * (x - y)\ndisplay(exp1.expand()) # expand expression\n\n\\(\\displaystyle x^{2} - y^{2}\\)\n\n\n\nexp2 = 6 * x**2 - x -2\ndisplay(exp2.factor()) # factor expression\n\n\\(\\displaystyle \\left(2 x + 1\\right) \\left(3 x - 2\\right)\\)\n\n\n\nexp3 = 2 * sp.sin(x)**2 + 2 * sp.cos(x)**2\ndisplay(exp3.simplify()) # simplify expression (trigonometric identity)\n\n\\(\\displaystyle 2\\)\n\n\n\n\nSubstitution\nSymbols can be substituted by an expression. This can also be used to numerically evaluate an expression. Multiple substitutions can be passed as a dictionary.\n\na, b = sp.symbols('a b')\n\nexp4 = x**3\ndisplay(exp4.subs(x, a + b).expand()) # substitute x with (a + b) and expand\n\n\\(\\displaystyle a^{3} + 3 a^{2} b + 3 a b^{2} + b^{3}\\)\n\n\n\nexp5 = sp.sin(x)\ndisplay(exp5.subs(x, sp.pi/4)) # evaluate expression at a specific value\n\n\\(\\displaystyle \\frac{\\sqrt{2}}{2}\\)\n\n\n\nexp6 = x**2 + 3*x*y - y**2\nvals = {x: 1, y: 2}\ndisplay(exp6.subs(vals)) # substitute multiple symbols\n\n\\(\\displaystyle 3\\)\n\n\n\n\nNumerical evaluation\nDecimal values can be enforced with a numerical evaluation.\n\nexp7 = sp.sqrt(2) + sp.sqrt(3)\ndisplay(exp7) # display expression with square roots\ndisplay(sp.N(exp7)) # numerical evaluation of expression with square roots\ndisplay(sp.N(exp7, 20)) # numerical evaluation with 20 digits precision\n\n\\(\\displaystyle \\sqrt{2} + \\sqrt{3}\\)\n\n\n\\(\\displaystyle 3.14626436994197\\)\n\n\n\\(\\displaystyle 3.1462643699419723423\\)\n\n\n\nexp8 = sp.sin(1) + sp.cos(2) * sp.exp(-3)\ndisplay(exp8)\ndisplay(sp.N(exp8))\n\n\\(\\displaystyle \\frac{\\cos{\\left(2 \\right)}}{e^{3}} + \\sin{\\left(1 \\right)}\\)\n\n\n\\(\\displaystyle 0.820752253805654\\)",
    "crumbs": [
      "SymPy",
      "Symbolic Calculations with SymPy"
    ]
  }
]